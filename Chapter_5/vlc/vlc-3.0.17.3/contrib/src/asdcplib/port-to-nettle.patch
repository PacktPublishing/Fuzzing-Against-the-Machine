diff -ruN asdcplib.old/configure.ac asdcplib/configure.ac
--- asdcplib.old/configure.ac	2017-01-17 22:38:59.494475028 +0100
+++ asdcplib/configure.ac	2017-01-17 22:40:43.762470383 +0100
@@ -65,7 +65,7 @@
    CXX=$CXX$ac_cv_sys_largefile_CC
 fi
 
-AX_LIB_OPENSSL([0.9.7])
+AX_LIB_NETTLE([0.9.7])
 AX_LIB_EXPAT
 AX_LIB_XERCES
 #AM_PATH_PYTHON([2.3], , [:])
diff -ruN asdcplib.old/m4/ax_lib_nettle.m4 asdcplib/m4/ax_lib_nettle.m4
--- asdcplib.old/m4/ax_lib_nettle.m4	1970-01-01 01:00:00.000000000 +0100
+++ asdcplib/m4/ax_lib_nettle.m4	2017-01-17 22:40:43.762470383 +0100
@@ -0,0 +1,277 @@
+# ===========================================================================
+#             ax_lib_nettle.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_LIB_NETTLE([MINIMUM-VERSION])
+#
+# DESCRIPTION
+#
+#   This macro provides tests of availability of Nettle of a
+#   particular version or newer. This macros checks for Nettle
+#   headers and libraries and defines compilation flags.
+#
+#   Macro supports following options and their values:
+#
+#   1) Single-option usage:
+#
+#     --with-nettle - yes, no or path to Nettle installation prefix
+#
+#   This macro calls:
+#
+#     AC_SUBST(NETTLE_CFLAGS)
+#     AC_SUBST(NETTLE_LDFLAGS)
+#     AC_SUBST(NETTLE_VERSION) - only if version requirement is used
+#
+#   And sets:
+#
+#     HAVE_NETTLE
+#
+# Copyright (c) 2008-2009 CineCert, LLC
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. The name of the author may not be used to endorse or promote products
+#    derived from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+AC_DEFUN([AX_LIB_NETTLE],
+[
+    AC_ARG_WITH([nettle],
+        AC_HELP_STRING([--with-nettle=@<:@ARG@:>@],
+            [use Nettle from given prefix (ARG=path); check standard prefixes (ARG=yes); disable (ARG=no)]
+        ),
+        [
+        if test "$withval" = "yes"; then
+            if test -d /var/local/include/nettle ; then
+                nettle_prefix=/var/local
+            elif test -d /usr/include/nettle ; then
+                nettle_prefix=/usr
+            else
+                nettle_prefix=""
+            fi
+            nettle_requested="yes"
+        elif test -d "$withval"; then
+            nettle_prefix="$withval"
+            nettle_requested="yes"
+        else
+            nettle_prefix=""
+            nettle_requested="no"
+        fi
+        ],
+        [
+        dnl Default behavior is implicit yes
+        if test -d /var/local/include/nettle ; then
+            nettle_prefix=/var/local
+        elif test -d /usr/include/nettle ; then
+            nettle_prefix=/usr
+        elif test -d /usr/local/include/nettle ; then
+            nettle_prefix=/usr/local            
+        else
+            nettle_prefix=""
+        fi
+        ]
+    )
+
+    NETTLE_CPPFLAGS=""
+    NETTLE_LDFLAGS=""
+    NETTLE_VERSION=""
+
+    dnl
+    dnl Collect include/lib paths and flags
+    dnl
+    run_nettle_test="no"
+
+    if test -n "$nettle_prefix"; then
+        nettle_include_dir="$nettle_prefix/include"
+        nettle_ldflags="-L$nettle_prefix/lib64 -L$nettle_prefix/lib"
+        run_nettle_test="yes"
+    elif test "$nettle_requested" = "yes"; then
+        if test -n "$nettle_include_dir" -a -n "$nettle_lib_flags"; then
+            run_nettle_test="yes"
+        fi
+    else
+        run_nettle_test="no"
+    fi
+
+    nettle_libs="-lnettle -lgmp"
+
+    dnl
+    dnl Check Nettle files
+    dnl
+    if test "$run_nettle_test" = "yes"; then
+
+        saved_CPPFLAGS="$CPPFLAGS"
+        CPPFLAGS="$CPPFLAGS -I$nettle_include_dir"
+
+        saved_LDFLAGS="$LDFLAGS"
+        LDFLAGS="$LDFLAGS $nettle_ldflags"
+
+        saved_LIBS="$LIBS"
+        LIBS="$nettle_libs $LIBS"
+
+        dnl
+        dnl Check Nettle headers
+        dnl
+        AC_MSG_CHECKING([for Nettle headers in $nettle_include_dir])
+
+        AC_LANG_PUSH([C])
+        AC_COMPILE_IFELSE([
+            AC_LANG_PROGRAM(
+                [[
+@%:@include <nettle/sha1.h>
+@%:@include <nettle/aes.h>
+                ]],
+                [[]]
+            )],
+            [
+            NETTLE_CPPFLAGS="-I$nettle_include_dir"
+            nettle_header_found="yes"
+            AC_MSG_RESULT([found])
+            ],
+            [
+            nettle_header_found="no"
+            AC_MSG_RESULT([not found])
+            ]
+        )
+        AC_LANG_POP([C])
+
+        dnl
+        dnl Check Nettle libraries
+        dnl
+        if test "$nettle_header_found" = "yes"; then
+
+            AC_MSG_CHECKING([for Nettle libraries])
+
+            AC_LANG_PUSH([C])
+            AC_LINK_IFELSE([
+                AC_LANG_PROGRAM(
+                    [[
+@%:@include <nettle/aes.h>
+@%:@include <nettle/sha1.h>
+#if (NETTLE_VERSION_NUMBER < 0x0090700f)
+#endif
+                    ]],
+                    [[
+
+                    ]]
+                )],
+                [
+                NETTLE_LDFLAGS="$nettle_ldflags"
+                NETTLE_LIBS="$nettle_libs"
+                nettle_lib_found="yes"
+                AC_MSG_RESULT([found])
+                ],
+                [
+                nettle_lib_found="no"
+                AC_MSG_RESULT([not found])
+                ]
+            )
+            AC_LANG_POP([C])
+        fi
+
+        CPPFLAGS="$saved_CPPFLAGS"
+        LDFLAGS="$saved_LDFLAGS"
+        LIBS="$saved_LIBS"
+    fi
+
+    AC_MSG_CHECKING([for Nettle])
+
+    if test "$run_nettle_test" = "yes"; then
+        if test "$nettle_header_found" = "yes" -a "$nettle_lib_found" = "yes"; then
+
+            AC_SUBST([NETTLE_CPPFLAGS])
+            AC_SUBST([NETTLE_LDFLAGS])
+            AC_SUBST([NETTLE_LIBS])
+
+            HAVE_NETTLE="yes"
+        else
+            HAVE_NETTLE="no"
+        fi
+
+        AC_MSG_RESULT([$HAVE_NETTLE])
+
+        dnl
+        dnl Check Nettle version
+        dnl
+        if test "$HAVE_NETTLE" = "yes"; then
+
+            nettle_version_req=ifelse([$1], [], [], [$1])
+
+            if test  -n "$nettle_version_req"; then
+
+                AC_MSG_CHECKING([if Nettle version is >= $nettle_version_req])
+
+                if test -f "$nettle_include_dir/nettle/nettlev.h"; then
+
+                    NETTLE_VERSION=`grep NETTLE_VERSION_TEXT $nettle_include_dir/nettle/nettlev.h \
+                                    | grep -v fips | grep -v PTEXT | cut -f 2 | tr -d \"`
+                    AC_SUBST([NETTLE_VERSION])
+
+                    dnl Decompose required version string and calculate numerical representation
+                    nettle_version_req_major=`expr $nettle_version_req : '\([[0-9]]*\)'`
+                    nettle_version_req_minor=`expr $nettle_version_req : '[[0-9]]*\.\([[0-9]]*\)'`
+                    nettle_version_req_revision=`expr $nettle_version_req : '[[0-9]]*\.[[0-9]]*\.\([[0-9]]*\)'`
+                    nettle_version_req_patch=`expr $nettle_version_req : '[[0-9]]*\.[[0-9]]*\.[[0-9]]*\([[a-z]]*\)'`
+                    if test "x$nettle_version_req_revision" = "x"; then
+                        nettle_version_req_revision="0"
+                    fi
+                    if test "x$nettle_version_req_patch" = "x"; then
+                        nettle_version_req_patch="\`"
+                    fi
+
+                    nettle_version_req_number=`expr $nettle_version_req_major \* $((0x10000000)) \
+                                               \+ $nettle_version_req_minor \* $((0x100000)) \
+                                               \+ $nettle_version_req_revision \* $((0x1000)) \
+                                               \+ $((1 + $(printf "%d" \'$nettle_version_req_patch) - $(printf "%d" \'a))) \* $((0x10)) \
+                                               \+ $((0xf))`
+
+                    dnl Calculate numerical representation of detected version
+                    nettle_version_number=`expr $(($(grep NETTLE_VERSION_NUMBER $nettle_include_dir/nettle/nettlev.h | cut -f 2 | tr -d L)))`
+
+                    nettle_version_check=`expr $nettle_version_number \>\= $nettle_version_req_number`
+                    if test "$nettle_version_check" = "1"; then
+                        AC_MSG_RESULT([yes])
+                    else
+                        AC_MSG_RESULT([no])
+                        AC_MSG_WARN([Found $NETTLE_VERSION, which is older than required. Possible compilation failure.])
+                    fi
+                else
+                    AC_MSG_RESULT([no])
+                    AC_MSG_WARN([Missing header nettle/nettlev.h. Unable to determine Nettle version.])
+                fi
+            fi
+        fi
+
+    else
+        HAVE_NETTLE="no"
+        AC_MSG_RESULT([$HAVE_NETTLE])
+
+        if test "$nettle_requested" = "yes"; then
+            AC_MSG_WARN([Nettle support requested but headers or library not found. Specify valid prefix of Nettle using --with-nettle=@<:@DIR@:>@])
+        fi
+    fi
+    if test "$HAVE_NETTLE" = "yes"; then
+        CPPFLAGS="$CPPFLAGS $NETTLE_CPPFLAGS -DHAVE_SSL=1"
+        LDFLAGS="$LDFLAGS $NETTLE_LDFLAGS $NETTLE_LIBS"
+    fi
+])
diff -ruN asdcplib.old/m4/ax_lib_openssl.m4 asdcplib/m4/ax_lib_openssl.m4
--- asdcplib.old/m4/ax_lib_openssl.m4	2017-01-17 22:38:59.494475028 +0100
+++ asdcplib/m4/ax_lib_openssl.m4	1970-01-01 01:00:00.000000000 +0100
@@ -1,290 +0,0 @@
-# ===========================================================================
-#             ax_lib_openssl.html
-# ===========================================================================
-#
-# SYNOPSIS
-#
-#   AX_LIB_OPENSSL([MINIMUM-VERSION])
-#
-# DESCRIPTION
-#
-#   This macro provides tests of availability of OpenSSL of a
-#   particular version or newer. This macros checks for OpenSSL
-#   headers and libraries and defines compilation flags.
-#
-#   Macro supports following options and their values:
-#
-#   1) Single-option usage:
-#
-#     --with-openssl - yes, no or path to OpenSSL installation prefix
-#
-#   This macro calls:
-#
-#     AC_SUBST(OPENSSL_CFLAGS)
-#     AC_SUBST(OPENSSL_LDFLAGS)
-#     AC_SUBST(OPENSSL_VERSION) - only if version requirement is used
-#
-#   And sets:
-#
-#     HAVE_OPENSSL
-#
-# Copyright (c) 2008-2009 CineCert, LLC
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions
-# are met:
-# 1. Redistributions of source code must retain the above copyright
-#    notice, this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright
-#    notice, this list of conditions and the following disclaimer in the
-#    documentation and/or other materials provided with the distribution.
-# 3. The name of the author may not be used to endorse or promote products
-#    derived from this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-
-AC_DEFUN([AX_LIB_OPENSSL],
-[
-    AC_ARG_WITH([openssl],
-        AC_HELP_STRING([--with-openssl=@<:@ARG@:>@],
-            [use OpenSSL from given prefix (ARG=path); check standard prefixes (ARG=yes); disable (ARG=no)]
-        ),
-        [
-        if test "$withval" = "yes"; then
-            if test -d /var/local/ssl/include ; then
-                openssl_prefix=/var/local/ssl
-            elif test -d /var/local/include/openssl ; then
-                openssl_prefix=/var/local
-            elif test -d /usr/local/ssl/include ; then
-                openssl_prefix=/usr/local/ssl
-            elif test -d /usr/lib/ssl/include ; then
-                openssl_prefix=/usr/lib/ssl
-            elif test -d /usr/include/openssl ; then
-                openssl_prefix=/usr
-            else
-                openssl_prefix=""
-            fi
-            openssl_requested="yes"
-        elif test -d "$withval"; then
-            openssl_prefix="$withval"
-            openssl_requested="yes"
-        else
-            openssl_prefix=""
-            openssl_requested="no"
-        fi
-        ],
-        [
-        dnl Default behavior is implicit yes
-        if test -d /var/local/ssl/include ; then
-            openssl_prefix=/var/local/ssl
-        elif test -d /var/local/include/openssl ; then
-            openssl_prefix=/var/local
-        elif test -d /usr/local/ssl/include ; then
-            openssl_prefix=/usr/local/ssl
-        elif test -d /usr/lib/ssl/include ; then
-            openssl_prefix=/usr/lib/ssl
-        elif test -d /usr/include/openssl ; then
-            openssl_prefix=/usr
-        else
-            openssl_prefix=""
-        fi
-        ]
-    )
-
-    OPENSSL_CPPFLAGS=""
-    OPENSSL_LDFLAGS=""
-    OPENSSL_VERSION=""
-
-    dnl
-    dnl Collect include/lib paths and flags
-    dnl
-    run_openssl_test="no"
-
-    if test -n "$openssl_prefix"; then
-        openssl_include_dir="$openssl_prefix/include"
-        openssl_ldflags="-L$openssl_prefix/lib64 -L$openssl_prefix/lib"
-        run_openssl_test="yes"
-    elif test "$openssl_requested" = "yes"; then
-        if test -n "$openssl_include_dir" -a -n "$openssl_lib_flags"; then
-            run_openssl_test="yes"
-        fi
-    else
-        run_openssl_test="no"
-    fi
-
-    openssl_libs="-lssl -lcrypto"
-
-    dnl
-    dnl Check OpenSSL files
-    dnl
-    if test "$run_openssl_test" = "yes"; then
-
-        saved_CPPFLAGS="$CPPFLAGS"
-        CPPFLAGS="$CPPFLAGS -I$openssl_include_dir"
-
-        saved_LDFLAGS="$LDFLAGS"
-        LDFLAGS="$LDFLAGS $openssl_ldflags"
-
-        saved_LIBS="$LIBS"
-        LIBS="$openssl_libs $LIBS"
-
-        dnl
-        dnl Check OpenSSL headers
-        dnl
-        AC_MSG_CHECKING([for OpenSSL headers in $openssl_include_dir])
-
-        AC_LANG_PUSH([C])
-        AC_COMPILE_IFELSE([
-            AC_LANG_PROGRAM(
-                [[
-@%:@include <openssl/opensslv.h>
-@%:@include <openssl/ssl.h>
-@%:@include <openssl/crypto.h>
-                ]],
-                [[]]
-            )],
-            [
-            OPENSSL_CPPFLAGS="-I$openssl_include_dir"
-            openssl_header_found="yes"
-            AC_MSG_RESULT([found])
-            ],
-            [
-            openssl_header_found="no"
-            AC_MSG_RESULT([not found])
-            ]
-        )
-        AC_LANG_POP([C])
-
-        dnl
-        dnl Check OpenSSL libraries
-        dnl
-        if test "$openssl_header_found" = "yes"; then
-
-            AC_MSG_CHECKING([for OpenSSL libraries])
-
-            AC_LANG_PUSH([C])
-            AC_LINK_IFELSE([
-                AC_LANG_PROGRAM(
-                    [[
-@%:@include <openssl/opensslv.h>
-@%:@include <openssl/ssl.h>
-@%:@include <openssl/crypto.h>
-#if (OPENSSL_VERSION_NUMBER < 0x0090700f)
-#endif
-                    ]],
-                    [[
-SSL_library_init();
-SSLeay();
-                    ]]
-                )],
-                [
-                OPENSSL_LDFLAGS="$openssl_ldflags"
-                OPENSSL_LIBS="$openssl_libs"
-                openssl_lib_found="yes"
-                AC_MSG_RESULT([found])
-                ],
-                [
-                openssl_lib_found="no"
-                AC_MSG_RESULT([not found])
-                ]
-            )
-            AC_LANG_POP([C])
-        fi
-
-        CPPFLAGS="$saved_CPPFLAGS"
-        LDFLAGS="$saved_LDFLAGS"
-        LIBS="$saved_LIBS"
-    fi
-
-    AC_MSG_CHECKING([for OpenSSL])
-
-    if test "$run_openssl_test" = "yes"; then
-        if test "$openssl_header_found" = "yes" -a "$openssl_lib_found" = "yes"; then
-
-            AC_SUBST([OPENSSL_CPPFLAGS])
-            AC_SUBST([OPENSSL_LDFLAGS])
-            AC_SUBST([OPENSSL_LIBS])
-
-            HAVE_OPENSSL="yes"
-        else
-            HAVE_OPENSSL="no"
-        fi
-
-        AC_MSG_RESULT([$HAVE_OPENSSL])
-
-        dnl
-        dnl Check OpenSSL version
-        dnl
-        if test "$HAVE_OPENSSL" = "yes"; then
-
-            openssl_version_req=ifelse([$1], [], [], [$1])
-
-            if test  -n "$openssl_version_req"; then
-
-                AC_MSG_CHECKING([if OpenSSL version is >= $openssl_version_req])
-
-                if test -f "$openssl_include_dir/openssl/opensslv.h"; then
-
-                    OPENSSL_VERSION=`grep OPENSSL_VERSION_TEXT $openssl_include_dir/openssl/opensslv.h \
-                                    | grep -v fips | grep -v PTEXT | cut -f 2 | tr -d \"`
-                    AC_SUBST([OPENSSL_VERSION])
-
-                    dnl Decompose required version string and calculate numerical representation
-                    openssl_version_req_major=`expr $openssl_version_req : '\([[0-9]]*\)'`
-                    openssl_version_req_minor=`expr $openssl_version_req : '[[0-9]]*\.\([[0-9]]*\)'`
-                    openssl_version_req_revision=`expr $openssl_version_req : '[[0-9]]*\.[[0-9]]*\.\([[0-9]]*\)'`
-                    openssl_version_req_patch=`expr $openssl_version_req : '[[0-9]]*\.[[0-9]]*\.[[0-9]]*\([[a-z]]*\)'`
-                    if test "x$openssl_version_req_revision" = "x"; then
-                        openssl_version_req_revision="0"
-                    fi
-                    if test "x$openssl_version_req_patch" = "x"; then
-                        openssl_version_req_patch="\`"
-                    fi
-
-                    openssl_version_req_number=`expr $openssl_version_req_major \* $((0x10000000)) \
-                                               \+ $openssl_version_req_minor \* $((0x100000)) \
-                                               \+ $openssl_version_req_revision \* $((0x1000)) \
-                                               \+ $((1 + $(printf "%d" \'$openssl_version_req_patch) - $(printf "%d" \'a))) \* $((0x10)) \
-                                               \+ $((0xf))`
-
-                    dnl Calculate numerical representation of detected version
-                    openssl_version_number=`expr $(($(grep OPENSSL_VERSION_NUMBER $openssl_include_dir/openssl/opensslv.h | cut -f 2 | tr -d L)))`
-
-                    openssl_version_check=`expr $openssl_version_number \>\= $openssl_version_req_number`
-                    if test "$openssl_version_check" = "1"; then
-                        AC_MSG_RESULT([yes])
-                    else
-                        AC_MSG_RESULT([no])
-                        AC_MSG_WARN([Found $OPENSSL_VERSION, which is older than required. Possible compilation failure.])
-                    fi
-                else
-                    AC_MSG_RESULT([no])
-                    AC_MSG_WARN([Missing header openssl/opensslv.h. Unable to determine OpenSSL version.])
-                fi
-            fi
-        fi
-
-    else
-        HAVE_OPENSSL="no"
-        AC_MSG_RESULT([$HAVE_OPENSSL])
-
-        if test "$openssl_requested" = "yes"; then
-            AC_MSG_WARN([OpenSSL support requested but headers or library not found. Specify valid prefix of OpenSSL using --with-openssl=@<:@DIR@:>@])
-        fi
-    fi
-    if test "$HAVE_OPENSSL" = "yes"; then
-        CPPFLAGS="$CPPFLAGS $OPENSSL_CPPFLAGS -DHAVE_SSL=1"
-        LDFLAGS="$LDFLAGS $OPENSSL_LDFLAGS $OPENSSL_LIBS"
-    fi
-])
diff -ruN asdcplib.old/README asdcplib/README
--- asdcplib.old/README	2017-01-17 22:38:59.494475028 +0100
+++ asdcplib/README	2017-01-17 22:40:43.762470383 +0100
@@ -56,7 +56,7 @@
 The author strives mightily to provide an API that is completely
 independent of operating system and other library dependencies,
 and which allows selective replacement of some modules for
-local needs.  Specifically, the essence parsers and OpenSSL
+local needs.  Specifically, the essence parsers and Nettle
 crypto functions can be replaced by linking to alternative
 implementations of the ASDCP:: objects which provide those
 services.
@@ -81,8 +81,8 @@
 this natively, an "nmake" build file and instructions can be found
 in the win32 subdirectory.  
 
-OpenSSL is also required, any recent version should be fine. See
-http://www.openssl.org/ for more information and download instructions.
+Nettle is also required, any recent version should be fine. See
+http://www.nettle.org/ for more information and download instructions.
 
 Optional support for writing Timed Text Track Files is supported by
 either Xerces-C or Expat. See http://xerces.apache.org/xerces-c/ or
@@ -817,7 +817,7 @@
    Macros are now used in any module that includes KM_log.h.
  o MPEG2 VES with run of zero values at the head is now OK.
  o Increased VESHeaderBufSize to 16K.
- o Added makefile support for local OpenSSL in ../openssl, if
+ o Added makefile support for local Nettle in ../nettle, if
    present.
  o The Kumu::PathIs*() functions now return false if a null or
    empty string is given (used to be an assert).
@@ -938,7 +938,7 @@
 
 
 2006.03.09 - full read-write
- o Removed ASDCP_WITHOUT_OPENSSL compile-time option.
+ o Removed ASDCP_WITHOUT_NETTLE compile-time option.
  o Full read/write now working on new MXF library
 
 
@@ -1104,8 +1104,8 @@
 
 
 2004.06.14 - plaintext read/write w/key generator v0.4.5
- o Project now uses OpenSSL (tested with 0.9.7d on win32, Linux, Darwin)
-   Use `make ASDCP_WITHOUT_OPENSSL=1` to make plaintext-only version
+ o Project now uses Nettle (tested with 0.9.7d on win32, Linux, Darwin)
+   Use `make ASDCP_WITHOUT_NETTLE=1` to make plaintext-only version
  o Accepts interior I frames when parsing MPEG2 VES
  o Improved error reporting on format errors
  o Added support for encryption to asdcp-test
diff -ruN asdcplib.old/README.orig asdcplib/README.orig
--- asdcplib.old/README.orig	1970-01-01 01:00:00.000000000 +0100
+++ asdcplib/README.orig	2017-01-17 22:40:39.146470588 +0100
@@ -0,0 +1,1159 @@
+
+$Id: README,v 1.111 2016/12/11 04:42:35 jhurst Exp $
+
+The asdcplib library is a set of objects that offer
+simplified access to files conforming to the sound and
+picture track file formats developed by the SMPTE Working
+Group DC28.20 (now TC 21DC).
+
+Recently, support has also been added for SMPTE draft ST
+2067-5 "IMF Essence Component", AKA "AS-02".  This code was
+donated by Fraunhofer IIS.  It carries additional copyright
+information which should be listed whenever you link the
+AS-02 elements of the library.  Please look at the top of
+the AS-02 files to see this copyright information.
+
+AS-02 support is carried in separate object modules, so
+unless you #include <AS_02.h> and link libas-02.so you are
+still using plain old asdcp.
+
+This work was originally funded by Digital Cinema Initiatives,
+LLC (DCI). Subsequent efforts have been funded by Deluxe
+Laboratories, Doremi Labs, CineCert LLC, Avica Technology
+and others.
+
+**The asdcplib project was originally housed on SourceForge.
+The project has moved to http://www.cinecert.com/asdcplib/
+
+The project formerly depended upon the mxflib project. Because
+of its focus on covering the whole of the MXF specifications,
+mxflib is considerably larger and more complex that what I
+require for this application. For this reason I have created
+a dedicated MXF implementation that is now part of this
+library. Special thanks to Matt Beard and Oliver Morgan for
+their great work and support.
+
+Thanks also to the members of the SMPTE DC28.20 packaging
+ad-hoc group and the members of the MXF Interop Initiative
+for their encouragement and support. Special thanks to
+Jim Whittlesey and Howard Lukk at DCI for proposing and
+supporting this project.
+
+
+Design Notes
+
+This library is intended (but of course not limited) for
+use by developers of commercial D-Cinema products (and now
+IMF!).  It is designed to be easily integrated into a wide
+variety of development environments.  Commercial users are
+strongly urged to use static linking (at least where you use
+this library) to prevent malicious in-field replacement of
+critical system modules. This recommendation should be
+considered wherever Open Source or Free software is being
+used in conjunction with critical security parameters, such
+as cryptographic keys.
+
+The author strives mightily to provide an API that is completely
+independent of operating system and other library dependencies,
+and which allows selective replacement of some modules for
+local needs.  Specifically, the essence parsers and OpenSSL
+crypto functions can be replaced by linking to alternative
+implementations of the ASDCP:: objects which provide those
+services.
+
+AS_DCP.h contains the entire AS-DCP API.  You do not need to
+read any of the other files, except maybe asdcp-test.cpp which
+contains detailed usage examples of each of the API's services.
+The KM_* files may be of interest for general development
+support, but may be ignored if all you want is simple AS-DCP
+support.
+
+Likewise, draft 2067-5 "IMF Essence Component" (AS-02) support
+is entirely contained in AS-02.h
+
+
+Build Instructions
+
+On more-or-less POSIX systems (OS X, Linux, and BSD), GNU make and 
+autotools are required to build asdcplib. The same configure script 
+will also build this package on Windows machines with Cygwin and
+MinGW installed. For those Windows users who would prefer to build
+this natively, an "nmake" build file and instructions can be found
+in the win32 subdirectory.  
+
+OpenSSL is also required, any recent version should be fine. See
+http://www.openssl.org/ for more information and download instructions.
+
+Optional support for writing Timed Text Track Files is supported by
+either Xerces-C or Expat. See http://xerces.apache.org/xerces-c/ or
+http://expat.sourceforge.net/ for source and build instructions.
+
+To configure and build, type './configure' followed by 'make'. There
+are several test targets on the POSIX side, but you need to assemble
+a set of test files to use them.  AS-02 support can be enabled with 
+ --enable-as-02.  
+
+I have tested this build on win32, Linux, OpenBSD, and Darwin
+platforms. Others may work as well.
+
+
+
+
+Utilities
+
+asdcp-test -  Writes, reads and verifies AS-DCP (MXF) track files.
+
+asdcp-wrap - Writes AS-DCP (MXF) track files.
+
+asdcp-unwrap - Extracts essence from AS-DCP (MXF) track files.
+
+asdcp-info - Displays information about AS-DCP (MXF) track files.
+
+asdcp-util - Calculates digests and generates random numbers and UUIDs.
+
+as-02-wrap - Writes AS-02 Essence Component files.
+
+as-02-unwrap - Extracts essence from AS-02 Essence Component files.
+
+kmfilegen - Writes and verifies large files using a platform-
+independent format. Use it to test issues related to large files.
+
+kmuuidgen, kmrandgen - generate UUID values and random numbers.
+
+wavesplit - Splits a WAVE file into two or more output files. Used
+  to untangle incorrectly-paired DCDM sound files.
+
+blackwave - Write a WAVE file of zeros.
+
+pinkwave - Write a WAVE file of SMPTE ST 2095 pink noise.
+
+j2c-test - Displays information about JP2K codestreams.
+
+Experimental feature: Prototype for High Dynamic Range is a wrapper
+for the IMF application that allows JPEG-2000 codestreams to be paired
+with opaque blobs of metadata.  AS-02 support must be enabled to
+build this feature, so --enable-as-02 must be enabled if
+--enable-phdr is to be used.  The following executable programs will be
+built:
+
+phdr-wrap - Writes AS-02 PHDR Essence Component files.
+
+phdr-unwrap - Extracts essence from AS-02 PHDR Essence Component files.
+
+
+Documentation
+
+The API documentation is mostly in AS_DCP.h. and AS_02.h  Read those
+files for a detailed description of the library's capabilities. Read
+asdcp-*.cpp and as-02-*.cpp files for library usage examples. The
+command-line utilities all respond to -h.
+
+
+Change History
+
+2016-12-10 - MDD bug fix 2.7.19
+ o The previous version (2.7.18) contained incorrect MDD.cpp and MDD.h
+   files which affect the PIMF and JP2KEssenceCompression labels.
+
+
+2016-12-10 - bug fixes 2.7.18
+ o Fixed *all* Partiton version numbers in AS-02 files (the previous attempt
+   only affected the header partition)
+ o Improved IMSC-1 profile detection. May not yet be perfect, experimentation
+   encouraged!
+ o Added IMF App2e UL values and new MXF data types ColorPrimary and
+   ThreeColorPrimaries (contributed by Schleich)
+ o Added picture descriptor elements MasteringDisplayPrimaries,
+   MasteringDisplayWhitePointChromaticity, MasteringDisplayMaximumLuminance,
+   and MasteringDisplayMinimumLuminance
+ o Added -o and -O options to as-02-wrap 
+ o Fixed as-02-wrap option -p when making 4:4:4 files
+ o Simplified as-02-wrap syntax description
+
+
+2016-12-01 - bug fixes 2.6.17
+ o Fixed Partiton and Preface version numbers in AS-02 files
+ o Replaced WIN32 directory scanner with dirent_win.h
+ o The NamespaceURI property of AS-02 timed text files has been exposed in the API
+   and via as-02-wrap -P. This behavior replaces previous bad behavior, but puts
+   responsibility for selecting the correct value on the operator.
+ o Exposed CreatePNGNameId and CreateFontNameId subroutines in AS_02::TimedText
+ o Adjusted UUID generation based on PNG and font names to exclude paths by
+   inserting a call to PathBasename at each Id generation site
+ o Fixed AS-02 timed text index partition
+ o Fixed contents of generic partiton EssenceContainers property in AS-DCP timed
+   text files
+ o Added PixelLayout to RGBAEssenceDescriptor (contributed by Schleich)
+ o Cleared up MXFGCP1FrameWrappedPictureElement / MXFGCP1FrameWrappedPictureElement
+   ambiguity. PHDR continues to use MXFGCP1FrameWrappedPictureElement.
+   MXFGCI1FrameWrappedPictureElement is supported for interlace.
+ o Added support for 192, 200 and 240 fps images, includes 96, 100 and 120 fpe stereo
+ o Added missing MCA properties to MCALabelSubDescriptor (contributed by Ruppel)
+ o New MXF data type: LineMapPair
+ o Added default 0,0 VideoLineMap value when wrapping CDCI with as-02-wrap
+ o Added VideoLineMap property to GenericPictureEssenceDescriptor
+ o Added timed text unwrap support to as-02-unwrap (contributed by Ruppel)
+ o Added prototype PIDM dynamic metadata wrapping, config with --enable-phdr
+   (Not for production use, caveat emptor, not the droids, etc.)
+
+
+2016-08-11 - bug fixes, 2.5.15
+
+ o Modified as-02-wrap to pass WhiteRefLev, BlackRefLev and ColorRange
+    (contributed by Elmer Musser / Rod Bogart)
+ o Fixed a bug in the index reader that allowed an out-of-bounds vector index
+   to be used.
+ o Modified the IndexEntry parser to ignore additional bytes belonging to slice
+   values.
+
+
+2016-05-06 - bug fixes, 2.5.14
+
+ o Release 2.5.12 caused two problems with Atoms and DTS-X wrapping that are
+   addressed by this release. The UL values that were changed to correct the
+   DCData (ST 429-14) implementation had two unintended side-effects:
+     1. v2.5.12 cannot read old DCData (and thus DTS-X) track files
+     2. v2.5.12 creates broken Atmos track files (incorrect ULs)
+   The fix for this involved the following changes:
+     1. ASDCP::DCData::(MXFReader|MXFWriter) are no longer base classes of
+        ASDCP::ATMOS::(MXFReader|MXFWriter).
+     2. New UL values have been added to carry the original Atoms UL values:
+        a. DolbyAtmosDCDataWrappingFrame
+        b. DolbyAtmosDCDataEssence
+        c. DolbyAtmosDCDataDescriptor
+     3. ASDCP::ATMOS::(MXFReader|MXFWriter) have been modified to use the
+        DolbyAtmosDCData* UL values.
+     4. ASDCP::DCData::MXFReader will parse files having either DCData* or
+        DolbyAtmosDCData* UL values.
+     5. ASDCP::DCData:: MXFWriter continues to use DCData* UL values from ST
+        429-14
+  o Some optional parameters of the MXF metadata packs were being erroneously
+    initialized with a value of zero (0), such as GenericPictureEssenceDescriptor
+    ::SignalStandard, GenericPictureEssenceDescriptor::SampledXOffset(0), etc.
+  o Added higher edit rates (96, 100, 120) to the cinema TimedText_Parser
+
+  o Defined bool ASDCP::UL::operator<(const UL& rhs) const, which is needed to
+    carry out the version-insensitive lookup policy when searching for ULs in a
+    std::map<> of UL entries.
+  o New files:  src/info.in src/CMakeLists.txt
+  o Removed filess:  AS_DCP_DCData_internal.h
+
+
+2016-03-17 - bug fixes, 2.5.12
+ o Changed default UNIX file permissions to "666"
+ o Changed default UNIX file permissions to "777"
+ o Added missing initializer for caltime::offset
+ o Fixed UL values for Aux Data files (per ST 429-14)
+ o Added support for default TTML fonts (ST2052_TextParser)
+ o Added Solaris patch to KM_fileio (Thanks Mikey!)
+ o Fixed the version byte in UL DataEssenceCoding
+ o Fixed duplicate linkage error for symbol MIME2str
+ o Big patch from Wolfgang Ruppel:
+   o Corrected erroneous fixed-tag values in ActiveHeight, ActiveWidth,
+     ActiveXOffset, ActiveYOffset UL definitions.
+   o Provided a stub implementation for Kumu::DirScannerEx (A real
+     implementation will follow soon.)
+   o Added as-02-info program
+   o Added Seek() method to PCM parsers
+   o Added CMakeLists.txt
+
+
+2015-11-10 - bug fixes, IMF text, pink noise, 2.5.11
+ o I moved personal dev environment from older gcc to newer clang.  Many
+   small changes were made to satisfy the new compiler:
+   - Altered many printf format codes to use the correct format for the
+     given integer type.
+   - Parenthesized some expressions to clarify previously ambiguous
+     expectation about precedence.
+   - Created macro KM_MACOSX for use in OS-specific code selection.
+   - Removed last uses of the old C-language abs(), now using Kumu::xabs().
+   - Removed last uses of the old C-language atoi(), not using strtol().
+ o Added platform-independent call Kumu::GetExecutablePath() (to be tested
+   on win32).
+ o Added new capabilities to Result_t.
+ o Added imlementation of SMPTE ST 2092-1 pink noise generator.
+ o Added pinkwave CLI utility.
+ o Added font support to the IMF timed-text wrapper.
+ o Fixed a bug that was causing Array properties to be written without
+   the (count, length) header (from PAL).
+ o General review of Batch/Array distinction throughout the project.
+ o Cleaned up definitions of optional properties in all MXF metadata packs.
+ o Fixed Win32 build (from Crowe).
+ o Fixed a bug that caused incorrect failure when parsing JPEG 2000
+   codestreams having fewer than five decomposition levels. (from Korneder).
+ o Fixed missing UUID generation in some instances of the MCALinkID property.
+ o Added -w option to asdcp-wrap to support use of WTF label with MCA.
+ o Altered asdcp-wrap to recognize "-C <UL>" when MCA is being used.
+ o Fixed broken -A <w>/<h> option in as-02-wrap and phdr-wrap.
+ o asdcp-wrap and as-02-wrap now allow split channel groups in MCA labels.
+
+
+2015-02-23 - bug fixes, 2.4.10
+  o Fixed a new bug introduced by the fix to large numbers of subtitle ancillary
+    resources.
+  o Added support for generic Aux Data (ST 429-14) to asdcp-wrap.
+
+
+2015-02-19 - PHDR feature, bug fixes, 2.4.9
+  o Modified PCMParser and PCMParserList to return partial frame buffers at the
+    end of a WAV input file.  This was needed to allow wrapping all samples into
+    an AS-02 audio file (which is clip-wrapped) in the case where the input file
+    has an odd number of samples with respect to the frame buffer size being
+    used.  If there is more than one input file the length of the last buffer
+    will be determined by PCMParserList to be the shortest of the input files.
+    Prior to this change, partial samples in an input WAV file have been
+    abandoned (i.e., not written out to the MXF file).  As a result, AS-DCP
+    applications will have to decide whether to abandon the partial last frame
+    (usually detected by testing frame_buffer.Size() != frame_buffer.Capacity())
+    or write it to the MXF file.  Programs written to the old API will write the
+    partial frame (i.e., new behavior.)  This should not be harmful since the
+    remainder of the buffer is zeroed and the output file will contain one
+    additional edit unit compared to the previous version.
+  o asdcp-wrap has been modified to test for the partial buffer and by default
+    will complain and abandon the buffer (i.e., same behavior but with a warning
+    message.)  A new command line switch (-g) alters this behavior and writes
+    the buffer to the MXF file (it still warns the user that this condition is
+    present.)
+  o as-02-wrap now wraps all samples from the input file to the MXF file. There
+    is no padding, the clip is exactly the set of samples from the input.
+  o as-02 unwrap is temporarily restricted to creating wav files that are
+    aligned with the frame buffer size.  This means that the output file will
+    be longer than the original WAV input in the case where the input file has
+    an odd number of samples with respect to the frame buffer size being used.
+    The pad samples are zero (silence).
+  o Modified CalcFramesFromDurationInSamples() to increment the count by one for
+    the case where the input file has an odd number of samples with respect to
+    the frame buffer size being used (previously it truncated the odd samples.)
+  o Fixed ST 429-5 / ST 2067-5 wrapping to increase header space when ancillary
+    resources are present (fixes a bug that cause the header to overflow the
+    allotted space when large numbers of PNG files were present.)
+  o Refactored GetXMLDocType() to use the XML parser.
+  o Added ParseFirstFromString() method to Kumu::XMLElement
+  o Removed Kumu::StringIsXML from the API.
+  o Added ASDCP::MXF::RGBALayout type
+  o Added J2CLayout property to JPEG2000PictureSubDescriptor
+  o Changed km_token_split() to retain empty elements in the output list
+  o Added PHDR wrapping for AS-02.
+  o Added J2CLayout property to the JPEG2000PictureSubDescriptor.  This
+    support is preliminary: the Raw data type is being used instead of
+    RGBALayout type, which will be in the next release.
+
+
+2014-10-2 - Bug fixes and enhancements, 2.2.6
+  o Fixed erroneous 377-4 MCA identifier in AS_DCP_PCM dump routine
+  o Fixed erroneous byte 13 in
+    WaveAudioDescriptor_ReferenceAudioAlignmentLevel label
+  o Added missing implementation of -W option to as-02.unwrap
+  o Fixed erroneous use of d-cinema ChannelAssignment label in as-02-wrap
+
+
+2014-10-01 - Bug fixes and enhancements, 2.2.5
+  o Finished AS-02 text wrap/unwrap
+  o Fixed fractional seconds parsing for Timestamp objects
+  o Updated KLVPacket to use 64-bit length; allows huge packets
+    in AS-02 PCM files
+  o cleaned up use of atoi() in the library
+
+
+2014-07-09 - Additional IMF/AS-02 support, bug fixes and enhancements, 2.1.4
+  o Added IMF App 2 edit rates in AS_02 namespace: EditRate_29_97, 
+    EditRate_59_94. 
+  o Revised AEC CBC context objects to copy the key rather than  
+    keep the reference passed in to it.
+  o Addressed a bug that would allow unimpeded iteration of component 
+    values in a JP2K::PictureDescriptor object.
+  o Addressed a bug that was incorrectly recording the sequence Duration 
+    in MXF Track objects.
+  o Added ASDCP::AtmosSyncChannelMixer::AppendSilenceChannels()
+  o Added a QCD decoder to the j2c parser.
+  o Altered ASDCP::KLVPacket::HasUL() to use version-blind matching.
+  o Fixed an uninitialized variable in MemIOReader::ReadString() that  
+    caused unbounded reads.
+  o Fixed broken ByteString::ArchiveLength() method
+  o Fixed broken version numbers on SoundfieldGroupLinkID and  
+    GroupOfSoundfieldGroupsLinkID UL values.
+  o Added DBOXMotionCodePrimaryStream and DBOXMotionCodeSecondaryStream UL 
+    values to the internal dictionary.
+  o Added optional prefix handling to MCA label generator.
+  o Re-factored MCA label generator to include additional  
+    metadata (Thanks to Mike Radford).
+  o Added new options to as-02-wrap.
+
+
+2014-01-06 – Additional IMF/AS-02 support, bug fixes 2.1.1
+  o Fixed missing-index-partion bugs for AS-02 files.
+  o Moved LocalFilenameResolver into the AS_DCP public API so that it
+    can be used by other modules including AS-02.
+  o Did further refactoring of AS-02 Writer classes to separate CBR
+    and VBR indexing implementations.
+  o Fixed wave wrapping UL in clip-wrapped AS-02 files.  Renamed some
+    UL constants to reflect "clip" or "frame" wrapping.
+  o Re-factored JP2K_PDesc_to_MD() and MD_to_JP2K_PDesc() to work
+    with GenericPictureEssenceDescriptor objects.
+  o Fixed a bug that was suppressing PictureComponentSizing,
+    CodingStyleDefault and QuantizationDefault when writing the
+    essence descriptor in a JP2K file (AS-DCP and AS-02).
+  o Fixed the version byte on the following UL values:
+    	  StereoscopicPictureSubDescriptor
+	  GenericPictureEssenceDescriptor_ColorPrimaries
+	  GenericPictureEssenceDescriptor_ActiveHeight
+	  GenericPictureEssenceDescriptor_ActiveWidth
+	  GenericPictureEssenceDescriptor_ActiveXOffset
+	  GenericPictureEssenceDescriptor_ActiveYOffset
+  o Added some essence descriptor options to as-02-wrap.
+  o Changed bit rate display in asdcp-info from mebi-bits/s to
+    mega-bits/s.
+  o Added "SMPTE" / "Interop" format type display to asdcp-info.
+  o Improved integration of ST 377-4 MCA concepts with ST 429-2 static
+    labels.
+  o Modified asdcp-wrap to assume -L when wrapping timed-text (since
+    there is no MXF text wrapping for Interop.)
+  o Added new EssenceType_t values for IMF/AS-02 track files.
+  o Added detection for AS-02 track files to ASDCP::EssenceType()
+  o Changed lots of "const char*" to "const std::string&" in the
+    APIs defined by KM_fileio.h and AS_DCP.h.
+  o Fixed VBR Delta Segment entries to correctly flag progressive
+    material.
+  o Fixed PCM unwrapping bugs in as-02-unwrap.
+  o Fixed missing return statement in ArchivableString::ArchiveLength
+    (thanks to both Kristof Provost and Franck Chopin) 
+  o Fixed broken sample alignment in RF64Writer (thanks to Wolfgang
+    Woehl and Dolby)
+  o Fixed win32 build (thanks to Dolby)
+  o fixed a bug that caused blackwave to only produce 96kHz WAV files.
+    (thanks to Stephane W)
+
+
+2013-07-02 – IMF/AS-02 support, bug fixes 2.0.0
+  o Massive refactoring of internals to allow easier implementation
+    of AS-02.  Some API changes were made as well (note that
+    OPAtomHeader is now OP1aHeader and RIP is no longer part of the
+    OP1aHeader.)  If you are using this project as a library (and
+    especially if you are keeping patches against it) PLEASE TAKE
+    TIME TO EVALUATE THIS RELEASE THOUROUGHLY BEFORE ADDING IT TO
+    YOUR RELEASE PATH.
+  o Final integration of Fraunhoffer IIS code contribution.  AS-02
+    files are now fully supported with some TODOs and two major
+    exceptions: LEAD indexes are not supported by the MXF writers
+    and interlace images are not yet supported.
+  o Added support for MCA labels (ST 428-12) to asdcp-wrap.  Note
+    that this project is still in the early stages of interop testing
+    so errors are likely present and don't expect any server to
+    make use of this feature.
+
+
+2013-07-01 - Bug fixes, enhancements 1.12.50
+  o Fixed missing return statement in ArchivableString::ArchiveLength
+    (thanks to both Kristof Provost and Franck Chopin) 
+  o Fixed broken sample alignment in RF64Writer (thanks to Dolby)
+  o Fixed win32 build (thanks to Dolby)
+
+
+2013-04-12 - Dolby Atmos support and more audio labels 1.11.49
+  o Significant code contribution from Dolby Laboratories to add
+    support for generic data track files as proposed in ST 21DC
+    and also Dolby Atmos track file support as a specialization.
+  o Added Dolby-contributed code to support generating the external
+    sync signal for d-cinema as proposed in ST 21DC.
+  o Added Dolby-contributed code to support RF64 WAVE files.
+  o Fixed UL error in ST 429-5 DM encoding (contributed by Dolby).
+  o Added ULs for ST 428-12 and Amd. 429-2 2013.  Please check!
+
+
+2013-02-20 - bug fixes, enhancements 1.10.48
+ o Refactored internals of the AS-DCP file readers.  While no
+   changes in behavior are intended, users are cautioned to test
+   thouroughly before use in production.
+ o Fixed a bug in ReadAncillaryResource that was causing bogus HMAC
+   failures when reading resources from a file.
+ o Fixed premature-release bug in the Expat version of the XML parser.
+   Thanks to Carsten Feldheim (IIS) for the tip.
+ o Fixed -W option in asdcp-unwrap.  Thanks to RGB.
+ o Added P-HFR support to asdcp-wrap (see URL for details:
+   http://isdcf.com/papers/ISDCF-HighFrameRate-DCP.pdf).
+ o Added support for SMPTE ST 428-21 "Archival Frame Rates".
+ o Added -P option to asdcp-wrap (inserts arbitrary UL into the
+   PictureEssenceCoding property when wrapping JP2K files.)
+ o Added support for 96 kHz files to blackwave.
+ o Added new path and string manglers to Kumu.
+ o Updated MCA ULs (I warned you...).  Again please take some
+   time to proof this work against ST 477-4 including the latest
+   drafts of the registries.
+       Changed the version byte (8 0f 16) to 0x0e:
+           MCALabelSubDescriptor
+           AudioChannelLabelSubDescriptor
+           SoundfieldGroupLabelSubDescriptor
+           GroupOfSoundfieldGroupsLabelSubDescriptor
+	   GroupOfSoundfieldGroupsLinkID
+       Changed bytes 8 and and 13 of SoundfieldGroupLinkID
+       Added items to the UL dictionary:
+	   MCAPartitionKind
+	   MCAPartitionNumber
+	   MCATitle
+	   MCATitleVersion
+	   MCATitleSubVersion
+	   MCAEpisode
+	   MCAAudioContentKind
+	   MCAAudioElementKind
+
+
+2012-08-07 - bug fix, 1.10.46
+ o Added missing zero-initializers to time values when parsing a
+   timestamp string (in the case where the optional [Thh:mm.[:ss]]
+   syntax is not present in an encoded string).
+
+2012-03-06 - bug fixes, enhancements 1.9.45
+ o Removed ASDCP::Timestamp, all items that were of that class are now 
+   of class Kumu::Timestamp
+ o Refactored Kumu::Timestamp to use KM_tai for internal representation 
+   (replaced public Y M D, h, m, s variables)
+ o Refactored Kumu::Timestamp to use KM_tai for WIN32 builds
+ o Added UTC offset awareness to Kumu::Timestamp
+ o Replaced "long GetSecondsSinceEpoch(void) const" with 
+   "ui64_t GetCTime() const"
+ o Corrected UL version segment in "7.1 DS" and "WTF" audio format
+   labels (corresponds with publication of ST 429-2:2011).
+ o Exposed MXF object interface (MXF.h, Metadata.h) via ASDCP MXFReader
+   and MXFWriter classes.
+ o Added UL values from ST 377-4:2012. >>>>NOTE: These are preliminary
+   values, subject to change upon final publication of not only ST 377-4
+   but also the relevant registries.  This is a good time to compare them
+   to the standard and complain if you think they are wrong!
+ o Added MCALabelSubDescriptor, AudioChannelLabelSubDescriptor,
+   SoundfieldGroupLabelSubDescriptor, and
+   GroupOfSoundfieldGroupsLabelSubDescriptor (from ST 377-4:2012) to
+   Metadata.h
+ o Changed some internals to make MXFWriter::OPAtomHeader() work correctly.
+ o Split asdcp-test into several different programs to help relieve
+   the impenetrable-list-of-arguments problem. asdcp-wrap, asdcp-unwrap
+   and asdcp-info take the place of asdcp-test's -c, -x and -i options,
+   respectively.  asdcp-util contains the remaining functions. Note that
+   asdcp-test is now DEPRECATED, new functionality and bug fixes will be
+   aimed at the new tools.  Also note that some options and calling
+   conventions are different for the new tools as compared to asdcp-test.
+   Please read the synopses and make sure you understand the new idioms.
+ o asdcp-wrap has a new argument, -C <UL>, that writes the given UL to the
+   ChannelAssignment item in the WaveAudioDescriptor (only useful when
+   writing PCM essence).
+
+
+2011-11-30 - bug fixes v1.8.44
+ o Corrected a wrong decryption UL selection when unwrapping MXF.
+
+
+2011-10-27 - bug fixes v1.8.43
+ o Corrected broken Essence UL matching. (Thanks to Michael Loder).
+
+
+2011-08-31 - bug fixes v1.8.42
+ o Added missing HFR support for PCM essence reader/writer.
+
+
+2011-08-30 - bug fixes, enhancements v1.8.41
+ o UL version byte now ignored when comparing UL values.
+ o Changed the version byte in the TimedTextEssence UL to 0x01.  There
+   is no published Essence Keys registry so it can't have a maintained
+   version number.
+ o JP2K Sequence Parser modified to skip directory entries that
+   are not files in the case where the parser is initialized with
+   a directory path.  When initialized with a list of file names
+   this check is not performed.  Based on a hint by Steve Quartly.
+ o Increased the size of the MPEG header parser buffer.
+ o Added missing FrameType() implementation to ASDCP::MPEG2::MXFReader.
+ o Added missing Close() implementations to MXF reader classes.
+ o Added missing Timestamp::Timestamp(const char* datestr) implementation.
+   (Thanks to Matt Sheby for this and the previous three items.)
+ o Fixed error in Kumu::FortunaRNG::FillRandom() that was returning the
+   end of the random buffer instead of the front (Thanks to Mike Radford).
+ o Added support for proposed sound channel format identifiers
+   '7.1DS' and 'WTF'.  Optimistically chose version '0x0c'.
+ o Added support for stereoscopic images in JP2K files at edit
+   rates of 48, 50 and 60 eups (96, 100 and 120 fps).
+
+
+2010.11.15 - bug fixes, enhancements v1.7.40
+ o Fixed bug in long KLV packet support (Thanks to Jim Radford).
+ o Fixed AvgBps in PCM files, *again*. Sorry for the crazy.
+ o More fixes and changes in support of 25, 30, 50, 60 fps.
+   (Thanks to Hans K. for the TC rate bug).
+ o Updated KLVFill UL version element to 0x02.
+ o Type change to support Xerces-C 3.x. (Thanks to Matt Sheby).
+ o Some internal API changes to KLV types. Does not affect
+   operation.
+ o Added NetworkLocator type to MXF metadata types.
+ o Added file offset display to klvwalk.
+
+
+2010.09.09 -  bug fixes, enhancements, v1.7.39
+ o Fixed bug in JP2K PictureDescriptor initialization in
+   JP2K::MXFReader::OpenRead() and JP2K::MXFSReader::OpenRead()
+ o Once again fiddling with AvgBbs. How can something so simple
+   be such a constant cause of trouble? Tested with 1-, 2- and
+   6-channel input Wav files.
+ o asdcp-test now accepts a directory name when making PCM
+   files (-c). The directory name should be the only filename
+   argument. All files in the directory must be Wav files
+   (mixed channel sizes OK). Files are sorted alphabetically by
+   filename. Hint: use numeric name infix to define order:
+   my_movie_00_L.wav
+   my_movie_01_R.wav
+   my_movie_02_C.wav
+   my_movie_03_LFE.wav
+   my_movie_04_LS.wav
+   my_movie_05_RS.wav
+
+
+2010.07.20 -  bug fixes, v1.6.37
+ o Fixed TimedTextResourceSubDescriptor UL value.
+
+
+2010.06.16 -  bug fixes, v1.6.36
+ o Added support for new Edit Rates to asdcp-test.cpp.
+ o Expanded timed-text file reader in asdcp-test.cpp.
+ o Fixed large BER value encoding (plaintext) and decoding
+   (plaintext and ciphertext). This feature was introduced in
+   v1.5.31).
+ o Fixed AvgBps value for multi-channel Wave input.
+
+
+2010.05.13 -  bug fixes, enhancements, v1.6.34
+ o ST 429-5 files have corrected ULs for DCTimedTextDescriptor and
+   GenericStream DataElement. Files made with previous versions of
+   the library are incompatible with this and future versions.
+ o Fixed File Package TrackNumber values. Th
+anks to Sankar.
+ o Added edit rate constants to AS_DCP.h (25, 30, 50, 60).
+ o Changed AudioDescriptor "SampleRate" element name to "EditRate"
+   to make it consistent with the other types.
+ o Now builds with XercesC 3.x.
+ o KM_memio.h has better const behavior.
+ o Fixed a bug in KM_memio.h string archiving.
+
+
+2010.01.05 -  bug fixes, enhancements, v1.5.32
+ o Re-fixed swapped Interop and SMPTE OP Atom UL values. The swap
+   introduced in v1.5.31 was done in error.
+ o Added -z,-Z options to asdcp-test (j2c parameter checking)
+ o Reformed jp2k-test as j2c-test, added help and list processing,
+   added to standard install target.
+
+
+2009.12.31 -  bug fixes, enhancements, v1.5.31
+ o Fixed swapped Interop and SMPTE OP Atom UL values.
+ o Added get_BER_length_for_value() subroutine.
+ o Modified ASDCP::h__Writer::WriteEKLVPacket() to allow larger BER
+   lengths for KLV packets larger than 16 MB. This was required to
+   support large font files in the SMPTE 429-5 implementation.
+
+
+2009.11.06 - bug fixes, enhancements, v1.5.29
+ o Fixed a bug that could cause HMAC values to be incorrectly
+   stored in MXF files.  Files created with versions of asdcplib
+   prior to this version may have incorrect HMAC values. 
+ o Improved handing of XML files for MXF wrapping.  
+ o Jpeg2000 codestream EditRate and SampleRate mismatches
+   now warns instead of returning an error. 
+ o Improved error handling in Jpeg2000 sequence parsing routines.  
+ o Added two methods to Kumu::Timestamp, AddSeconds(), to add (or
+   subtract) seconds to a time value, and GetSecondsSinceEpoch()
+   to get the number of seconds since the unix epoch.
+ o Added new option to asdcp-test, '-a', to specify a UUID when
+   creating MXF files.
+ o Added support for specifying the intrinsic duration of MXF files
+   containing timed text.
+ o Added new option to wavesplit, '-i', to display WAV file metadata.
+
+
+2009.05.21 - bug fixes, v.1.4.24
+ o Fixed a bug that caused incorrect SubDescriptors UL values to be 
+   written into interop format MXF track files.  Note that this involved
+   a substantial reorganization of MXF internals.  Please test thoroughly
+   in your application before using in production.  Note that this is a 
+   significant bug fix and track files created with 1.4.22 may be incompatible
+   with other systems.  
+
+
+2009.04.09 - SMPTE format fixes, enhancements and bug fixes, v.1.4.22
+ o asdcplib now uses GNU autotools on POSIX systems to configure 
+   and build.  See "./configure" for details.  Note that two options, 
+   --enable-freedist and --with-python are not enabled in the free
+   version of asdcplib and should not be used.  
+ o Added build option (CONFIG_RANDOM_UUID) to enable mixed case UUID
+   generation when environment variable KM_USE_RANDOM_UUID is defined.
+ o Fixed a condition that could cause an error to occur when wrapping 
+   SMPTE format timed text track files that do not define a starting 
+   frame.
+ o Updated ULs for SMPTE format track files.
+ o SampleRate added to JP2K metadata
+ o Support for wrapping 96kHz WAV files added.
+ o Updated ULs for audio channel formats  (ChannelFormat)  
+ o Updated font subdescriptor MIME Types for TimedText Trackfiles.
+ o Changed time implementation to support dates beyond Jan 19th, 2038.
+ o Xerces-C XML parser support added.  
+ o New build method for Windows (see win32/README.txt for details).
+ o Added new functionality in Kumu to recursively create and delete files 
+   and directories, and get free disk space for a given volume path.
+ o Added a method to Kumu::Timestamp, AddMinutes(), to add (or subtract) 
+   minutes to a time value.  
+ o Improved how Kumu::Timestamp parses timestamps with offsets. 
+ o Fixed a bug that caused incorrect HMAC values to be calculated.
+
+
+2008.02.16 - SMPTE format fixes, bug fixes v.1.3.18
+ o Added correct SMPTE UL for StereoscopicPictureSubDescriptor.
+ o Exposed JP2K metadata parser as ParseMetadataIntoDesc().
+ o Added simple stereoscopic framebuffer to support paired ReadFrame()
+   and WriteFrame() methods (allows simpler integration with other
+   single-buffer code).
+ o Improved detection of JPEG Interop stereoscopic files.
+ o Win32 build fixes (Thanks to Mike Crowe at DTS).
+ o Added the WITH_MD macro to the makefile. Set this value to one
+   to build Win32 with /MD[d] instead of /MT[d].
+ o The Generic Container UL has been added to the EssenceContainers
+   set in the header partition pack for encrypted files. It has always
+   been there in plaintext files.
+ - Below this point the changes are internal and should not affect you
+   unless you use Kumu directly.
+ o Major refactoring of KM_log.[h|cpp].
+ o Fixed buffer re-sizing issue in Kumu::ByteString.
+ o Replaced type IdentifierList with ArchivableList.
+ o Added COPYING file to the release bundle.
+
+
+2007.12.13 - Bug fixes v.1.2.17
+ o Changed Result_t implementation to use int instead of long, which
+   was causing trouble on some 64 bit platforms.
+ o Fixed EKLV HMAC. NOTE: Breaks backward compatibility with older
+   Interop files. To validate these files, use asdcplib-1.1.14. This
+   should not cause too much trouble since files with broken and
+   non-broken HMAC have been in the wild for years without issue.
+ o Fixed HMAC sequence numbering in encrypted stereoscopic files.
+ o Finished stereoscopic test targets in the makefile.
+ o Fixed the win32 build, now expects VS2005 compiler by default,
+   use WITH_VC6=1 top get VC6 flags.
+ o Stereoscopic and Timed Text modes now have SMPTE UL values.
+   NOTE: SMPTE 429-5 and 429-10 are not yet published. It is possible
+   that these UL values may change before publication. Please use
+   caution when using these features for production work.
+ o Changed a bunch of symbol names in the 429-5 implementation to
+   better match the spec.
+ o Added -U option to asdcp-test to dump the UL library to stdout.
+ o Fixed erroneous placement of the PictureEssenceCoding UL in JP2K
+   files (Interop and SMPTE modes).
+
+
+2007.10.22 - Timed Text, Stereoscopic Picture and Bug fixes v.1.2.16
+ o Significant API changes have been made. Please read all entries
+   in this changelog to be sure you understand the changes. Also
+   note that some changes have been made to LS_MXF_SMPTE files that
+   are incompatible with earlier releases (e.g., EKLV HMAC). If
+   you are looking for a stable interop release, use  v.1.1.14.
+ o Fixed RFC 2104 HMAC implementation for LS_MXF_SMPTE only. The
+   broken implementation has been maintained for Interop mode.
+ o Added support for draft SMPTE 429-5 Timed Text Track File. This
+   is still waiting for official SMPTE ULs, so do not use it for
+   shipping products.  An XML parser is needed to create a Timed
+   Text Track File; Expat is now an optional part of the build.
+   Make with WITH_XML_PARSER=1 to link with Expat. If you do not
+   link with expat, you will get an error when using the TimedText::
+   DCSubtitleParser class. See also S429-5-cgi.cpp for an example
+   that shows how to serve plaintext MXF file elements directly via
+   HTTP.
+ o Added support for draft SMPTE 429-10 Stereoscopic Picture Track
+   File, including the JPEG Interop version. This is still waiting
+   for official SMPTE ULs, so do not use it with LS_MXF_SMPTE for
+   shipping products.  
+ o Refactored the following files as a side-effect of the above
+   work: AS_DCP_JP2K.cpp AS_DCP_MPEG2.cpp AS_DCP_PCM.cpp
+   AS_DCP_MXF.cpp AS_DCP_internal.h MXF.[h|cpp] MXFTypes.[h|cpp]
+   Metadata.[h|cpp] h__Reader.cpp h__Writer.cpp klvwalk.cpp.
+   WARNING: While significant effort has been extended to make sure
+   that these changes do not affect existing stable file support,
+   users are cautioned to test this release thouroughly.
+ o Added a large set of filesystem path manglers to KM_fileio.h. See
+   path-test.cpp for example usage. The path manglers have not yet
+   been tested on win32 platforms (they are currently used only by
+   the Timed Text module.
+ o The PathIsFile(), PathIsDirectory() and FileSize() subroutines
+   have been modified to accept const std::string& instead of
+   const char*.
+ o Added namespace and parsing support (Expat) to Kumu::XMLElement
+   (currently used only for Timed Text support). Also added some
+   new accessors.
+ o Altered MXF::UTF16String to use mbtowc() and wctomb().
+
+
+2007.03.31 - Bug fixes v.1.1.14
+ o Fixed KeyFrameOffset value in MPEG wrapping to have negative
+   value. This is probably not yet complete for handling all
+   types of GOPs. Please send chunks of MPEG-2 VES that you
+   find which break this. Thanks to Doremi.
+ ** no other file format changes in this release **
+ o Fixed error in RIP interpretation when reading arbitrary (i.e.,
+   non-MXF) files.
+ o Fixed a memory leak in ASDCP::MXF::OPAtomHeader when used
+   in read mode. Thanks to Mahesh Bajaj for pointing out this
+   bug and the one above.
+ o Removed asserts from KM_fileio, replaced with RESULT_WRITEFAIL
+   return value statements.
+ o Added -s and -p to the makefile install target.
+ o Altered ByteString behavior to use target Length() in copy
+   operations (instead of Capacity()).
+ o Added new Set() method to ByteString.
+ o Fixed a bug in ByteString::Unarchive() that caused the operation
+   to fail when the buffer was smaller than the read (i.e., when
+   Capacity() was called).
+ o Added IdentifierList class to KM_util.h.
+ o Changed some Error() messages to Debug() in Wav.cpp
+ o Revived jp2k-test.cpp and asdcp-mem-test.cpp (they both had
+   stale #includes).
+
+
+2007.02.15 - Bug fixes v1.1.13
+ o Removed 'VDescObj->SampleRate.Numerator = VDesc.FrameRate;'
+   from MPEG2_VDesc_to_MD() in AS_DCP_MPEG2.cpp, was line 76.
+ o Added KM_TEST_NULL_STR_L() and KM_TEST_NULL_L() macros to
+   KM_log.h. These versions log the location of the null value.
+   Macros are now used in any module that includes KM_log.h.
+ o MPEG2 VES with run of zero values at the head is now OK.
+ o Increased VESHeaderBufSize to 16K.
+ o Added makefile support for local OpenSSL in ../openssl, if
+   present.
+ o The Kumu::PathIs*() functions now return false if a null or
+   empty string is given (used to be an assert).
+ o Cleaned up the install target in the makefile.
+ o Fixed SMPTE 429-6 HMAC -- FIPS 186-2 implementation was
+   laughably incorrect. Thanks to Doremi for pointing this out.
+ o Removed default parameter to HMACContext::InitKey().
+ o Cleaned up messages and CLI arg handling in asdcp-test.
+
+
+2006.11.19 - Mo better stuff v1.1.12
+ o Changed read-only Result_t accessor methods to const.
+ o Added Base64 (-B) option to kmrandgen.
+ o Removed 16-bit alignment restriction from kmrandgen.
+ o Improved WAV file extraction speed (Thanks to Jim Radford
+   for pointing this out).
+ o Added single-channel split for WAV extraction (asdcp-test -1).
+ o Fixed remainder bug in h__RNG::fill_rand().
+
+
+2006.11.03 - Bug fixes v1.1.11
+ o Increased index table entry list size to 5000.
+ o Added length checking to TLV writer (returns error if TLV
+   payload exceeds 64kB).
+ o Fixed partition header and RIP errors related to 2-partition
+   files (MXF Interop mode).
+ o Added -t option to asdcp-test (SHA-1 digest with Base64 output
+   on stdout).
+ o Fixed Sub Descriptor reference bug (Thanks to Denis Leconte
+   for dogged determination).
+ o Added directory-of-wav detection to RawEssenceType()
+ o Modified MXF::Partition::AddChildObject() to only generate
+   a UUID if the InstanceID is unset.
+ o Added ComponentMaxRef & ComponentMinRef to RGBAEssenceDescriptor.
+   More to follow.
+ o Added detection of 2K/4K jp2c, writing correct 4K metadata.
+
+
+2006.10.05 - Bug fixes v1.1.10
+ o Changed RM_RELEASE to RL_RELEASE in MXFTypes.h.
+ o Changed the MXF writer to use RL_RELEASE (was RL_DEVELOPMENT).
+ o Really fixed source reference chain.
+ o Updated JP2K file package label.
+ o Changed location of JPEG2000PictureSubDescriptor in the
+   header (was erroneously before Preface).
+ o Altered LS_MXF_INTEROP to produce 2-partition files.
+
+
+2006.09.25 - Bug fixes v1.1.9
+ o Fixed SourcePackageID value. All files will be 'original',
+   i.e. SourcePackageID will be all zeros. Let me know if you
+   want to set SourcePackageID.
+ o Fixed compiler warnings on some Linux platforms
+ o Fixed the build so that BUILD_DIR is no longer created
+   as a dependency.
+ o Added duration detection to the raw essence parsers. The
+   MPEG parser uses a nasty approximation so don't use it
+   without paying close attention to the result.
+ o Modified PCMParserList to make it more useful as a base
+   class.
+ o Fixed bugs and re-organized command-line help in asdcp-test
+   and klvwalk.
+ o Fixed two-partition file reads.
+ o Fixed Win32 PRNG initialization.
+ o Renamed asdcp-lf-test as kmfilegen.
+ o Added kmrandgen and kmuuidgen.
+ o Added string retrieval mechanism to Result_t.
+ o Refactored Kumu::Identifier and its sub-classes.
+ o Altered Kumu::PathIsFile to return true when the path
+   is a symbolic link (unix only).
+ o Altered Kumu::FileWriter::OpenWrite to use file creation
+   mode 0664 (was 0644) (unix only).
+ o Added Kumu::WriteStringIntoFile() subroutine.
+
+
+2006.04.05 - Bug fixes and new stuff v1.1.7
+ o Fixed a bug in the MPEG parser that caused it to fail when
+   handling start codes spanning buffer boundaries
+ o Added wavesplit and blackwave utility programs
+ o Added support for revised SMPTE HMAC key derivation when
+   using LS_MXF_SMPTE
+ o Refactored platform compatibility and general utilities
+   into a new sub-library "Kumu". There are no new build
+   steps or dependencies, but some important things have
+   changed:
+   + Result_t is no longer an enum, it is now a class.
+     Library result codes are now declared as const objects
+     like this:
+
+     const Kumu::Result_t RESULT_FORMAT (-101, "The file...");
+
+     The macros ASDCP_SUCCESS and ASDCP_FAILURE still work
+     the same way thanks to an operator overload for type long.
+     See KM_error.h for more information.
+   + The logging interface has been moved out of AS_DCP.h
+     and into KM_log.h
+ o Some of the command line utilities that were using headers
+   other than AS_DCP.h have been changed to use the Kumu
+   equivalents. If you have code based on those utilities, you
+   will have to update by hand.
+ o Added new types to the EssenceType_t enum.
+ o The guard macro for Win32 code has changed from WIN32 to
+   KM_WIN32.
+
+
+2006.03.2x - new stuff
+ o Proper handling of stream-id byte of essence UL values
+ o writes 3-partition files, reads 2-part or 3-part
+
+
+2006.03.16 - bug fixes plus
+ o Removed SMPTE_LABELS compile-time option. The reader will now
+   silently accept either SMPTE or MXF Interop labels, the writer
+   can be instructed which to use at runtime. Default is Interop.
+ o Added an AIFF reader. Support is preliminary, it works with the
+   AIFF files I have on hand.
+ o More code refactoring. More to come.
+
+
+2006.03.09 - full read-write
+ o Removed ASDCP_WITHOUT_OPENSSL compile-time option.
+ o Full read/write now working on new MXF library
+
+
+2005.00.00 - A New Hope
+ o The temporary mxf-lite has been removed. MXF files are now 
+   managed via the objects in KLV.h, MXFTypes.h MXF.h and
+   Metadata.h. This release does not support writing MXF files.
+ o Fixed a header interpretation error in the Wav parser.
+
+
+2005.00.00 - The Reformation
+ o Removed mxflib as a dependency by forking the necessary
+   functions and placing them in the mxf-lite subdirectory.
+   Please note that the very heavy modifications done here
+   render all comparisson to mxflib code a substantial task.
+   All errors are now mine and users are warned not to bug
+   Oliver or Matt for help with this code. The version of
+   mxflib at the time of the fork was: 0.5.1.3.
+
+
+2005.06.03 - bug fixes v0.10.18
+ o Updated UL batch to include GC UL.
+
+
+2005.05.27 - bug fixes v0.10.17
+ o Un-did essence container and compression descriptor changes.
+   The default build reflects MXF Interop decisions as of 26 May.
+ o Added note about build versions to README (see above).
+ o Added warnings to SMPTE_LABELS builds.
+ o Fixed JP2K essence container label.
+
+
+2005.05.02 - bug fixes v0.10.16
+ o Reorganized internal files, added file reader object, added OS
+   portability header, removed and renamed some files. If you have a
+   patch against previous versions of the source, you should check
+   it thoroughly.
+ o Added RGBA attributes to JP2K descriptor.
+ o Changed interface to CodestreamParser.
+ o Added JP2K parser implementation. It is parsing each frame but is
+   not yet being used to populate the descriptor.
+ o Added 48fps option for `asdcp-test -p`.
+ o Added picture rate constants to AS_DCP.h (23.976, 24, 48).
+ o Added sample rate constant to AS_DCP.h (48k).
+ o Changed asdcp-test to encrypt picture headers by default
+   (plaintext offset will be 0), added -E option to allow
+   plaintext headers.
+
+
+2005.04.28 - bug fixes v0.9.15
+ o The XML descriptors for the crypto DMS have moved in mxflib to
+   the file DMS_Crypto.xml (they were in DMS_DCPENC.xml).  Older
+   installations should update the file from mxflib.
+ o Added Close() and Seek() to ~MyFileWriter(), cleaned up headers
+ o Added UUID generator output mode (-u).
+ o Added -S option to extract PCM essence into stereo wav files
+ o Added more UL testing and conformance checking.
+ o Added macro SMPTE_LABELS which causes the library to be built
+   with SMPTE (as opposed to MXF Interop) labels. This is not
+   set by default, and currently only affects the PCM container
+   label and encrypted element label.
+ o Cleaned up the GNUmakefile test targets, the source files
+   are now named with the TEST_FILE_PREFIX macro.
+ o enabled 23.976-framed PCM (2002 samples per frame)
+ o The size of the asdcp-test frame buffer for picture essence
+   may now be set from the command line (-b).  The default is 4MB.
+ o h__Reader::ReadEKLVPacket() now tests the UL (duh) and switches
+   on the value, allowing plaintext and ciphertext frames to
+   be mixed in the file.
+ o Fixed error in UUID generator format.
+ o JP2K files now use the GenericPictureDescriptor to store
+   ContainerDuration and SampleRate. SampleRate is mapped
+   to EditRate in the PictureDescriptor struct. This fixes
+   the second caveat from the 0.8.13 release.
+ o Fxed bug in PCMParserList that was miscalculating the extent
+   of a PCM sample.  This bug did not affect API users, it was
+   only present in asdcp-test.
+ o Fixed EditRate on PCM files (was showing sample rate)
+ o Fixed Encrypted Essence Container UL
+ o Fixed BlockAlign value for PCM essence
+
+ - The following changes were provided by Jeff Loewenguth
+ - Thanks Jeff!
+ o Moved the DMS CryptographicFramework entry from the material
+   package to the source package
+ o Fixed erroneous Source Essence Container Label value
+ o Fixed broken sort of JP2K frames in JP2K parser
+ o Added FindFrameGOPStart() method to the MPEG2 MXFReader
+ o Added missing length values for EKLV packets without HMAC
+ o -x with JP2K essence writes to files with 6 digit names
+   (up from 5 digits).
+ o The Key ID may now be specified as an argument to asdcp-test
+    (-j <key-id-string>)
+
+
+2004.12.30 - bug fixes + wav files v0.8.14
+ o Added WAV file write to asdcp-test (uses mxflib::waveheader_t).
+ o Three-partition files reading properly.  adscplib still writes
+   two-partition files.
+ o Changes in the mxflib WAV essence parser API had broken
+   asdcplib's ability to read essence from a WAV file.  I have
+   fixed this bug, but at the expense of breaking compatibility
+   with older versions of mxflib. Beware!
+ o Removed redundant (but working) bin-text-bin conversions.
+
+
+2004.12.23 - JPEG 2000 support v0.8.13
+ o Reads/writes JPEG 2000 essence in plaintext and ciphertext
+   with the following caveats:
+    - The Picture Essence Descriptor is empty.
+    - Because there is no essence descriptor, the reader code
+      in asdcp-test has no idea how many frames are in the file
+      and ends with an out-of-bounds frame error.  This error
+      is being suppressed in asdcp-test for the current release.
+ o Still broken when reading three-partition files.
+
+
+2004.10.22 - fixes and UL updates v0.7.11
+ WARNING: COMPATIBILITY BREAKPOINT
+ Files created with this and future versions of this library are
+ not compatible with previous versions of this library.  As you
+ might suspect, files created with previous versions of this
+ library are not compatible with  this and future versions.
+
+ o h__Reader will now open a three-partitition file (untested)
+ o Moved DMS from Material partition to File partition
+ o Added length fields to appropriate places in EKLV packet 
+
+
+2004.10.22 - fixes and UL updates v0.7.10
+ o fixed frame buffer handling of externally allocated buffer,
+   created unit test (asdcp-mem-test)
+ o added operator==() and operator!=() to Rational type
+ o fixed some type-related compiler warnings
+ o asdcp-test -p now works on unwrap
+ o updated some ULs to match documentation (thanks to Arun
+   for the submission)
+ o canonicalized line endings
+
+
+2004.07.02 - full plaintext + ciphertext read/write v0.6.9
+ o HMAC, plaintext offest and raw ciphertext read supported
+ o back to proper CBR index
+ o MPEG temporal offset working
+
+
+2004.07.01 - plaintext + ciphertext read/write v0.5.8
+ o encryption of MPEG and PCM essence supported with the
+   following caveats:
+   - no HMAC support
+   - no plaintext offest support
+   - no raw ciphertext read support
+ o moved to reflecting the whole KLV triplet in the CBR
+   index (now incompatible with mxflib, still searching
+   for info about what's "right")
+ o awaitng the following fixes/features:
+   - retrieve Temporal Offset from index in MPEG2::Reader
+   - test for correct ULs when reading frame triplets
+   - fix header metadata items for encrypted files
+   - HMAC support
+   - plaintext offest support
+   - raw ciphertext read support
+
+
+2004.06.14 - plaintext read/write w/key generator v0.4.5
+ o Project now uses OpenSSL (tested with 0.9.7d on win32, Linux, Darwin)
+   Use `make ASDCP_WITHOUT_OPENSSL=1` to make plaintext-only version
+ o Accepts interior I frames when parsing MPEG2 VES
+ o Improved error reporting on format errors
+ o Added support for encryption to asdcp-test
+ o Added RNG for asdcp-test (non-production use only, see notes in FortunaRNG.h)
+ o Implemented CBC encrypt, decrypt module
+ o Added partial TemporalOffset retrieval from MPEG2 parser
+ o Fixed win32 binmode bug
+
+
+2004.05.12 - plaintext read/write v0.3.4
+ o Full read/write of plaintext MPEG-2 VES and WAV files
+   (does not yet support mux from or demux to 2 channel pairs)
+ o Builds with autoconf-based mxflib
+ o Added ASDCP_ prefix to macros
+ o Updated documentation, fixed documentation errors
+ o Simplified API for MXF writer setup
+ o Decoupled essence parsers from MXF writers
+ o added raw ciphertext support to FrameBuffer
+ o Cleaned up Get/Set naming confusion
+ o Added missing const qualifiers
+
+
+2004.04.27 - preview release v0.2.1
+ o hasty release for quick review
+ o this release may not build with mxflib using autoconf.
+ o writes plaintext AS-DCP MPEG2 essence files
+ o tested under win32 and linux. FreeBSD and Darwin do not work
+
+
+2004.02.04 - First release (v0.1.1):
+ o asdcp-test is mostly complete. It should correctly provide
+   access to the read and info capabilities of the library.
+ o The MPEG2 reader is functional but not fully tested.
+ o Some file format integrity tests remain to be coded.
+ o The PCM reader is mostly complete, I am having difficulty
+   getting a suitable test file from mxfwrap.
+ o The makefile creates a static library module. The API
+   will cleanly support a DSO (or DLL). Let me know if DSO
+   support is important to you.
+ o Nothing is thread safe. Thread safety was not a requirement
+   in the initial project definition. Thread safety may be added
+   above the mxflib/klvlib level. Let me know if it is important
+   to you.
+ o The files xmldict.xml and types.xml must be in the current
+   directory when the program is run. The files are supplied
+   with mxflib. Runtime location of the files is not currently
+   a project goal. Comments on how best to handle this situation
+   would be appreciated. See AS_DCP.cpp at init_mxf_types()
+   for a more detailed discussion.
+
+--
diff -ruN asdcplib.old/src/AS_DCP_AES.cpp asdcplib/src/AS_DCP_AES.cpp
--- asdcplib.old/src/AS_DCP_AES.cpp	2017-01-17 22:38:59.494475028 +0100
+++ asdcplib/src/AS_DCP_AES.cpp	2017-01-17 22:40:55.166469875 +0100
@@ -37,25 +37,16 @@
 using Kumu::DefaultLogSink;
 
 using namespace ASDCP;
-const int KEY_SIZE_BITS = 128;
 
-#include <openssl/aes.h>
-#include <openssl/sha.h>
-#include <openssl/bn.h>
-#include <openssl/err.h>
 
+#include <nettle/aes.h>
+#include <nettle/sha1.h>
+#include <nettle/bignum.h>
 
-void
-print_ssl_error()
-{
-  char err_buf[256];
-  unsigned long errval = ERR_get_error();
-  DefaultLogSink().Error("OpenSSL: %s\n", ERR_error_string(errval, err_buf));
-}
 
 //------------------------------------------------------------------------------------------
 
-class ASDCP::AESEncContext::h__AESContext : public AES_KEY
+class ASDCP::AESEncContext::h__AESContext : public aes128_ctx
 {
 public:
   Kumu::SymmetricKey m_KeyBuf;
@@ -79,12 +70,8 @@
   m_Context = new h__AESContext;
   m_Context->m_KeyBuf.Set(key);
 
-  if ( AES_set_encrypt_key(m_Context->m_KeyBuf.Value(), KEY_SIZE_BITS, m_Context) )
-    {
-      print_ssl_error();
-      return RESULT_CRYPT_INIT;
-    }
-
+  // nettle set/get encrypt key returns void
+  aes128_set_encrypt_key(m_Context,  m_Context->m_KeyBuf.Value());
   return RESULT_OK;
 }
 
@@ -144,7 +131,7 @@
       for ( ui32_t i = 0; i < CBC_BLOCK_SIZE; i++ )
 	tmp_buf[i] = in_p[i] ^ Ctx->m_IVec[i]; 
           
-      AES_encrypt(tmp_buf, Ctx->m_IVec, Ctx);
+      aes128_encrypt(Ctx, sizeof(tmp_buf), Ctx->m_IVec, tmp_buf);
       memcpy(out_p, Ctx->m_IVec, CBC_BLOCK_SIZE);
 
       in_p += CBC_BLOCK_SIZE;
@@ -158,7 +145,7 @@
 
 //------------------------------------------------------------------------------------------
 
-class ASDCP::AESDecContext::h__AESContext : public AES_KEY
+class ASDCP::AESDecContext::h__AESContext : public aes128_ctx
 {
 public:
   Kumu::SymmetricKey m_KeyBuf;
@@ -182,12 +169,7 @@
   m_Context = new h__AESContext;
   m_Context->m_KeyBuf.Set(key);
 
-  if ( AES_set_decrypt_key(m_Context->m_KeyBuf.Value(), KEY_SIZE_BITS, m_Context) )
-    {
-      print_ssl_error();
-      return RESULT_CRYPT_INIT;
-    }
-
+  aes128_set_decrypt_key(m_Context, m_Context->m_KeyBuf.Value()) ;
   return RESULT_OK;
 }
 
@@ -226,7 +208,7 @@
 
   while ( block_size )
     {
-      AES_decrypt(in_p, out_p, Ctx);  
+      aes128_decrypt(Ctx, sizeof(in_p), out_p,in_p );
 
       for ( ui32_t i = 0; i < CBC_BLOCK_SIZE; i++ )
 	out_p[i] ^= Ctx->m_IVec[i];
@@ -250,7 +232,7 @@
 
 class HMACContext::h__HMACContext
 {
-  SHA_CTX m_SHA;
+  sha1_ctx m_SHA;
   byte_t  m_key[KeyLen];
   ASDCP_NO_COPY_CONSTRUCT(h__HMACContext);
 
@@ -264,12 +246,12 @@
   // SMPTE 429.6 MIC key generation
   void SetKey(const byte_t* key)
   {
-    byte_t rng_buf[SHA_DIGEST_LENGTH*2];
-    Kumu::Gen_FIPS_186_Value(key, KeyLen, rng_buf, SHA_DIGEST_LENGTH*2);
+    byte_t rng_buf[SHA1_DIGEST_SIZE*2];
+    Kumu::Gen_FIPS_186_Value(key, KeyLen, rng_buf, SHA1_DIGEST_SIZE*2);
 
     // rng_buf contains two rounds, x0 and x1 (each 160 bits).
     // Use x1 per SMPTE 430-6-2006 Sec. 7.10
-    memcpy(m_key, rng_buf+SHA_DIGEST_LENGTH, KeyLen);
+    memcpy(m_key, rng_buf+SHA1_DIGEST_SIZE, KeyLen);
     Reset();
   }
 
@@ -278,14 +260,14 @@
   {
     static byte_t key_nonce[KeyLen] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 
 					0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff };
-    byte_t sha_buf[SHA_DIGEST_LENGTH];
+    byte_t sha_buf[SHA1_DIGEST_SIZE];
 
     // 7.10: MICKey = trunc( SHA1 ( key, key_nonce ) )
-    SHA_CTX SHA;
-    SHA1_Init(&SHA);
-    SHA1_Update(&SHA, key, KeyLen);
-    SHA1_Update(&SHA, key_nonce, KeyLen);
-    SHA1_Final(sha_buf, &SHA);
+    sha1_ctx SHA;
+    sha1_init(&SHA);
+    sha1_update(&SHA, KeyLen, key);
+    sha1_update(&SHA, KeyLen, key_nonce);
+    sha1_digest(&SHA, sizeof(sha_buf), sha_buf);
     memcpy(m_key, sha_buf, KeyLen);
     Reset();
   }
@@ -300,14 +282,14 @@
 
     memset(m_SHAValue, 0, HMAC_SIZE);
     m_Final = false;
-    SHA1_Init(&m_SHA);
+    sha1_init(&m_SHA);
 
     // H(K XOR opad, H(K XOR ipad, text))
     //                 ^^^^^^^^^^
     for ( ui32_t i = 0; i < B_len; i++ )
       xor_buf[i] ^= ipad_const;
 
-    SHA1_Update(&m_SHA, xor_buf, B_len);
+    sha1_update(&m_SHA, B_len, xor_buf);
   }
 
   //
@@ -316,37 +298,37 @@
   {
     // H(K XOR opad, H(K XOR ipad, text))
     //                             ^^^^
-    SHA1_Update(&m_SHA, buf, buf_len);
+    sha1_update(&m_SHA, buf_len,buf);
   }
 
   //
   void
   Finalize()
   {
-    SHA_CTX SHA;
-    SHA1_Init(&SHA);
+    sha1_ctx SHA;
+    sha1_init(&SHA);
 
     byte_t xor_buf[B_len];
     memset(xor_buf, 0, B_len);
     memcpy(xor_buf, m_key, KeyLen);
 
-    SHA1_Init(&SHA);
+    sha1_init(&SHA);
 
     // H(K XOR opad, H(K XOR ipad, text))
     //   ^^^^^^^^^^
     for ( ui32_t i = 0; i < B_len; i++ )
       xor_buf[i] ^= opad_const;
 
-    SHA1_Update(&SHA, xor_buf, B_len);
+    sha1_update(&SHA, B_len, xor_buf);
 
     // H(K XOR opad, H(K XOR ipad, text))
     //               ^
-    SHA1_Final(m_SHAValue, &m_SHA);
-    SHA1_Update(&SHA, m_SHAValue, HMAC_SIZE);
+    sha1_digest( &m_SHA, sizeof(m_SHAValue), m_SHAValue);
+    sha1_update(&SHA, sizeof(m_SHAValue), m_SHAValue);
 
     // H(K XOR opad, H(K XOR ipad, text))
     // ^
-    SHA1_Final(m_SHAValue, &SHA);
+    sha1_digest( &m_SHA, sizeof(m_SHAValue),m_SHAValue);
     m_Final = true;
   }
 };
diff -ruN asdcplib.old/src/AS_DCP.h asdcplib/src/AS_DCP.h
--- asdcplib.old/src/AS_DCP.h	2017-01-17 22:38:59.494475028 +0100
+++ asdcplib/src/AS_DCP.h	2017-01-17 22:40:55.166469875 +0100
@@ -52,7 +52,7 @@
  o SMPTE ST 422:2006 - JPEG 2000 picture in GC
  o SMPTE ST 382:2007 - WAV/PCM sound in GC
  o IETF RFC 2104 - HMAC/SHA1
- o NIST FIPS 197 - AES (Rijndael) (via OpenSSL)
+ o NIST FIPS 197 - AES (Rijndael) (via Nettle)
 
  o MXF Interop Track File Specification
  o MXF Interop Track File Essence Encryption Specification
@@ -75,7 +75,7 @@
  o Read header metadata from an AS-DCP file
 
 This project depends upon the following libraries:
- - OpenSSL http://www.openssl.org/
+ - Nettle http://www.nettle.org/
  - Expat http://expat.sourceforge.net/  or
      Xerces-C http://xerces.apache.org/xerces-c/
    An XML library is not needed if you don't need support for SMPTE ST 429-5:2009.
diff -ruN asdcplib.old/src/asdcp-test.cpp asdcplib/src/asdcp-test.cpp
--- asdcplib.old/src/asdcp-test.cpp	2017-01-17 22:38:59.494475028 +0100
+++ asdcplib/src/asdcp-test.cpp	2017-01-17 22:40:55.166469875 +0100
@@ -53,7 +53,7 @@
 #include <WavFileWriter.h>
 #include <MXF.h>
 #include <Metadata.h>
-#include <openssl/sha.h>
+#include <nettle/sha.h>
 
 #include <iostream>
 #include <assert.h>
@@ -1889,8 +1889,8 @@
 
   ASDCP_TEST_NULL_STR(filename);
   FileReader Reader;
-  SHA_CTX Ctx;
-  SHA1_Init(&Ctx);
+  sha1_ctx Ctx;
+  sha1_init(&Ctx);
   ByteString Buf(8192);
 
   Result_t result = Reader.OpenRead(filename);
@@ -1907,7 +1907,7 @@
 	}
 
       if ( ASDCP_SUCCESS(result) )
-	SHA1_Update(&Ctx, Buf.Data(), read_count);
+	sha1_update(&Ctx, read_count, Buf.Data());
     }
 
   if ( ASDCP_SUCCESS(result) )
@@ -1915,7 +1915,7 @@
       const ui32_t sha_len = 20;
       byte_t bin_buf[sha_len];
       char sha_buf[64];
-      SHA1_Final(bin_buf, &Ctx);
+      sha1_digest(&Ctx, sizeof(bin_buf), bin_buf);
 
       fprintf(stdout, "%s %s\n", base64encode(bin_buf, sha_len, sha_buf, 64), filename);
     }
diff -ruN asdcplib.old/src/asdcp-test.cpp.orig asdcplib/src/asdcp-test.cpp.orig
--- asdcplib.old/src/asdcp-test.cpp.orig	1970-01-01 01:00:00.000000000 +0100
+++ asdcplib/src/asdcp-test.cpp.orig	2017-01-17 22:40:39.146470588 +0100
@@ -0,0 +1,2101 @@
+/*
+Copyright (c) 2003-2014, John Hurst
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. The name of the author may not be used to endorse or promote products
+   derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+/*! \file    asdcp-test.cpp
+    \version $Id: asdcp-test.cpp,v 1.54 2016/11/22 17:58:19 jhurst Exp $       
+    \brief   AS-DCP file manipulation utility
+
+  This program provides command line access to the major features of the asdcplib
+  library, and serves as a library unit test which provides the functionality of
+  the supported use cases.
+
+  For more information about asdcplib, please refer to the header file AS_DCP.h
+
+  WARNING: While the asdcplib library attempts to provide a complete and secure
+  implementation of the cryptographic features of the AS-DCP file formats, this
+  unit test program is NOT secure and is therefore NOT SUITABLE FOR USE in a
+  production environment without some modification.
+
+  In particular, this program uses weak IV generation and externally generated
+  plaintext keys. These shortcomings exist because cryptographic-quality
+  random number generation and key management are outside the scope of the
+  asdcplib library. Developers using asdcplib for commercial implementations
+  claiming SMPTE conformance are expected to provide proper implementations of
+  these features.
+*/
+
+#include <KM_fileio.h>
+#include <KM_prng.h>
+#include <PCMParserList.h>
+#include <WavFileWriter.h>
+#include <MXF.h>
+#include <Metadata.h>
+#include <openssl/sha.h>
+
+#include <iostream>
+#include <assert.h>
+
+using namespace ASDCP;
+
+const ui32_t FRAME_BUFFER_SIZE = 4 * Kumu::Megabyte;
+
+//------------------------------------------------------------------------------------------
+//
+// command line option parser class
+
+static const char* PROGRAM_NAME = "asdcp-test";  // program name for messages
+const ui32_t MAX_IN_FILES = 16;             // maximum number of input files handled by
+                                            //   the command option parser
+
+// local program identification info written to file headers
+class MyInfo : public WriterInfo
+{
+public:
+  MyInfo()
+  {
+      static byte_t default_ProductUUID_Data[UUIDlen] =
+      { 0x7d, 0x83, 0x6e, 0x16, 0x37, 0xc7, 0x4c, 0x22,
+	0xb2, 0xe0, 0x46, 0xa7, 0x17, 0xe8, 0x4f, 0x42 };
+      
+      memcpy(ProductUUID, default_ProductUUID_Data, UUIDlen);
+      CompanyName = "WidgetCo";
+      ProductName = "asdcp-test";
+      ProductVersion = ASDCP::Version();
+  }
+} s_MyInfo;
+
+
+
+// Increment the iterator, test for an additional non-option command line argument.
+// Causes the caller to return if there are no remaining arguments or if the next
+// argument begins with '-'.
+#define TEST_EXTRA_ARG(i,c)    if ( ++i >= argc || argv[(i)][0] == '-' ) \
+                                 { \
+                                   fprintf(stderr, "Argument not found for option -%c.\n", (c)); \
+                                   return; \
+                                 }
+//
+void
+banner(FILE* stream = stdout)
+{
+  fprintf(stream, "\n\
+%s (asdcplib %s)\n\n\
+Copyright (c) 2003-2015 John Hurst\n\n\
+asdcplib may be copied only under the terms of the license found at\n\
+the top of every file in the asdcplib distribution kit.\n\n\
+Specify the -h (help) option for further information about %s\n\n",
+	  PROGRAM_NAME, ASDCP::Version(), PROGRAM_NAME);
+}
+
+//
+void
+usage(FILE* stream = stdout)
+{
+  fprintf(stream, "\
+USAGE: %s -c <output-file> [-3] [-a <uuid>] [-b <buffer-size>]\n\
+       [-d <duration>] [-e|-E] [-f <start-frame>] [-j <key-id-string>]\n\
+       [-k <key-string>] [-l <label>] [-L] [-M] [-p <frame-rate>] [-R]\n\
+       [-s <num>] [-v] [-W] [-z|-Z] <input-file> [<input-file-2> ...]\n\
+\n\
+       %s [-h|-help] [-V]\n\
+\n\
+       %s -i [-H] [-n] [-v] <input-file>\n\
+\n\
+       %s -g | -u\n\
+\n\
+       %s -G [-v] <input-file>\n\
+\n\
+       %s -t <input-file>\n\
+\n\
+       %s -x <file-prefix> [-3] [-b <buffer-size>] [-d <duration>]\n\
+       [-f <starting-frame>] [-m] [-p <frame-rate>] [-R] [-s <num>] [-S|-1]\n\
+       [-v] [-W] [-w] <input-file>\n\n",
+	  PROGRAM_NAME, PROGRAM_NAME, PROGRAM_NAME, PROGRAM_NAME,
+	  PROGRAM_NAME, PROGRAM_NAME, PROGRAM_NAME);
+
+  fprintf(stream, "\
+Major modes:\n\
+  -3                - With -c, create a stereoscopic image file. Expects two\n\
+                      directories of JP2K codestreams (directories must have\n\
+                      an equal number of frames; left eye is first).\n\
+                    - With -x, force stereoscopic interpretation of a JP2K\n\
+                      track file.\n\
+  -c <output-file>  - Create an AS-DCP track file from input(s)\n\
+  -g                - Generate a random 16 byte value to stdout\n\
+  -G                - Perform GOP start lookup test on MXF+Interop MPEG file\n\
+  -h | -help        - Show help\n\
+  -i                - Show file info\n\
+  -t                - Calculate message digest of input file\n\
+  -U                - Dump UL catalog to stdout\n\
+  -u                - Generate a random UUID value to stdout\n\
+  -V                - Show version information\n\
+  -x <root-name>    - Extract essence from AS-DCP file to named file(s)\n\
+\n");
+
+  fprintf(stream, "\
+Security Options:\n\
+  -e                - Encrypt MPEG or JP2K headers (default)\n\
+  -E                - Do not encrypt MPEG or JP2K headers\n\
+  -j <key-id-str>   - Write key ID instead of creating a random value\n\
+  -k <key-string>   - Use key for ciphertext operations\n\
+  -m                - verify HMAC values when reading\n\
+  -M                - Do not create HMAC values when writing\n\
+\n");
+
+  fprintf(stream, "\
+Read/Write Options:\n\
+  -a <UUID>         - Specify the Asset ID of a file (with -c)\n\
+  -b <buffer-size>  - Specify size in bytes of picture frame buffer.\n\
+                      Defaults to 4,194,304 (4MB)\n\
+  -d <duration>     - Number of frames to process, default all\n\
+  -f <start-frame>  - Starting frame number, default 0\n\
+  -l <label>        - Use given channel format label when writing MXF sound\n\
+                      files. SMPTE 429-2 labels: '5.1', '6.1', '7.1', '7.1DS', 'WTF'.\n\
+                      Default is no label (valid for Interop only).\n\
+  -L                - Write SMPTE UL values instead of MXF Interop\n\
+  -p <rate>         - fps of picture when wrapping PCM or JP2K:\n\
+                      Use one of [23|24|25|30|48|50|60], 24 is default\n\
+  -R                - Repeat the first frame over the entire file (picture\n\
+                      essence only, requires -c, -d)\n\
+  -S                - Split Wave essence to stereo WAV files during extract.\n\
+                      Default is multichannel WAV\n\
+  -1                - Split Wave essence to mono WAV files during extract.\n\
+                      Default is multichannel WAV\n\
+  -W                - Read input file only, do not write source file\n\
+  -w <width>        - Width of numeric element in a series of frame file names\n\
+                      (use with -x, default 6).\n\
+  -z                - Fail if j2c inputs have unequal parameters (default)\n\
+  -Z                - Ignore unequal parameters in j2c inputs\n\
+\n");
+
+  fprintf(stream, "\
+Info Options:\n\
+  -H                - Show MXF header metadata, used with option -i\n\
+  -n                - Show index, used with option -i\n\
+\n\
+Other Options:\n\
+  -s <num>          - Number of bytes of frame buffer to be dumped as hex to\n\
+                      stderr, used with option -v\n\
+  -v                - Verbose, prints informative messages to stderr\n\
+\n\
+  NOTES: o There is no option grouping, all options must be distinct arguments.\n\
+         o All option arguments must be separated from the option by whitespace.\n\
+         o An argument of \"23\" to the -p option will be interpreted\n\
+           as 24000/1001 fps.\n\
+\n");
+}
+
+//
+enum MajorMode_t
+{
+  MMT_NONE,
+  MMT_INFO,
+  MMT_CREATE,
+  MMT_EXTRACT,
+  MMT_GEN_ID,
+  MMT_GEN_KEY,
+  MMT_GOP_START,
+  MMT_DIGEST,
+  MMT_UL_LIST,
+};
+
+//
+PCM::ChannelFormat_t
+decode_channel_fmt(const std::string& label_name)
+{
+  if ( label_name == "5.1" )
+    return PCM::CF_CFG_1;
+
+  else if ( label_name == "6.1" )
+    return PCM::CF_CFG_2;
+  
+  else if ( label_name == "7.1" )
+    return PCM::CF_CFG_3;
+
+  else if ( label_name == "WTF" )
+    return PCM::CF_CFG_4;
+
+  else if ( label_name == "7.1DS" )
+    return PCM::CF_CFG_5;
+
+  fprintf(stderr, "Error decoding channel format string: %s\n", label_name.c_str());
+  fprintf(stderr, "Expecting '5.1', '6.1', '7.1', '7.1DS' or 'WTF'\n");
+  return PCM::CF_NONE;
+}
+
+//
+//
+class CommandOptions
+{
+  CommandOptions();
+
+public:
+  MajorMode_t mode;
+  bool   error_flag;     // true if the given options are in error or not complete
+  bool   key_flag;       // true if an encryption key was given
+  bool   key_id_flag;    // true if a key ID was given
+  bool   asset_id_flag;  // true if an asset ID was given
+  bool   encrypt_header_flag; // true if mpeg headers are to be encrypted
+  bool   write_hmac;     // true if HMAC values are to be generated and written
+  bool   read_hmac;      // true if HMAC values are to be validated
+  bool   split_wav;      // true if PCM is to be extracted to stereo WAV files
+  bool   mono_wav;       // true if PCM is to be extracted to mono WAV files
+  bool   verbose_flag;   // true if the verbose option was selected
+  ui32_t fb_dump_size;   // number of bytes of frame buffer to dump
+  bool   showindex_flag; // true if index is to be displayed
+  bool   showheader_flag; // true if MXF file header is to be displayed
+  bool   no_write_flag;  // true if no output files are to be written
+  bool   version_flag;   // true if the version display option was selected
+  bool   help_flag;      // true if the help display option was selected
+  bool   stereo_image_flag; // if true, expect stereoscopic JP2K input (left eye first)
+  ui32_t number_width;   // number of digits in a serialized filename (for JPEG extract)
+  ui32_t start_frame;    // frame number to begin processing
+  ui32_t duration;       // number of frames to be processed
+  bool   duration_flag;  // true if duration argument given
+  bool   do_repeat;      // if true and -c -d, repeat first input frame
+  bool   use_smpte_labels; // if true, SMPTE UL values will be written instead of MXF Interop values
+  bool   j2c_pedantic;   // passed to JP2K::SequenceParser::OpenRead
+  ui32_t picture_rate;   // fps of picture when wrapping PCM
+  ui32_t fb_size;        // size of picture frame buffer
+  ui32_t file_count;     // number of elements in filenames[]
+  const char* file_root; // filename pre for files written by the extract mode
+  const char* out_file;  // name of mxf file created by create mode
+  byte_t key_value[KeyLen];  // value of given encryption key (when key_flag is true)
+  byte_t key_id_value[UUIDlen];// value of given key ID (when key_id_flag is true)
+  byte_t asset_id_value[UUIDlen];// value of asset ID (when asset_id_flag is true)
+  const char* filenames[MAX_IN_FILES]; // list of filenames to be processed
+  PCM::ChannelFormat_t channel_fmt; // audio channel arrangement
+
+  //
+  Rational PictureRate()
+  {
+    if ( picture_rate == 16 ) return EditRate_16;
+    if ( picture_rate == 18 ) return EditRate_18;
+    if ( picture_rate == 20 ) return EditRate_20;
+    if ( picture_rate == 22 ) return EditRate_22;
+    if ( picture_rate == 23 ) return EditRate_23_98;
+    if ( picture_rate == 24 ) return EditRate_24;
+    if ( picture_rate == 25 ) return EditRate_25;
+    if ( picture_rate == 30 ) return EditRate_30;
+    if ( picture_rate == 48 ) return EditRate_48;
+    if ( picture_rate == 50 ) return EditRate_50;
+    if ( picture_rate == 60 ) return EditRate_60;
+    if ( picture_rate == 96 ) return EditRate_96;
+    if ( picture_rate == 100 ) return EditRate_100;
+    if ( picture_rate == 120 ) return EditRate_120;
+    if ( picture_rate == 192 ) return EditRate_192;
+    if ( picture_rate == 200 ) return EditRate_200;
+    if ( picture_rate == 240 ) return EditRate_240;
+    return EditRate_24;
+  }
+
+  //
+  const char* szPictureRate()
+  {
+    if ( picture_rate == 16 ) return "16";
+    if ( picture_rate == 18 ) return "18.182";
+    if ( picture_rate == 20 ) return "20";
+    if ( picture_rate == 22 ) return "21.818";
+    if ( picture_rate == 23 ) return "23.976";
+    if ( picture_rate == 24 ) return "24";
+    if ( picture_rate == 25 ) return "25";
+    if ( picture_rate == 30 ) return "30";
+    if ( picture_rate == 48 ) return "48";
+    if ( picture_rate == 50 ) return "50";
+    if ( picture_rate == 60 ) return "60";
+    if ( picture_rate == 96 ) return "96";
+    if ( picture_rate == 100 ) return "100";
+    if ( picture_rate == 120 ) return "120";
+    if ( picture_rate == 192 ) return "192";
+    if ( picture_rate == 200 ) return "200";
+    if ( picture_rate == 240 ) return "240";
+    return "24";
+  }
+
+  //
+  CommandOptions(int argc, const char** argv) :
+    mode(MMT_NONE), error_flag(true), key_flag(false), key_id_flag(false), asset_id_flag(false),
+    encrypt_header_flag(true), write_hmac(true), read_hmac(false), split_wav(false), mono_wav(false),
+    verbose_flag(false), fb_dump_size(0), showindex_flag(false), showheader_flag(false),
+    no_write_flag(false), version_flag(false), help_flag(false), stereo_image_flag(false),
+    number_width(6), start_frame(0),
+    duration(0xffffffff), duration_flag(false), do_repeat(false), use_smpte_labels(false), j2c_pedantic(true),
+    picture_rate(24), fb_size(FRAME_BUFFER_SIZE), file_count(0), file_root(0), out_file(0),
+    channel_fmt(PCM::CF_NONE)
+  {
+    memset(key_value, 0, KeyLen);
+    memset(key_id_value, 0, UUIDlen);
+
+    for ( int i = 1; i < argc; i++ )
+      {
+
+	if ( (strcmp( argv[i], "-help") == 0) )
+	  {
+	    help_flag = true;
+	    continue;
+	  }
+         
+	if ( argv[i][0] == '-'
+	     && ( isalpha(argv[i][1]) || isdigit(argv[i][1]) )
+	     && argv[i][2] == 0 )
+	  {
+	    switch ( argv[i][1] )
+	      {
+	      case '1': mono_wav = true; break;
+	      case '2': split_wav = true; break;
+	      case '3': stereo_image_flag = true; break;
+
+	      case 'a':
+		asset_id_flag = true;
+		TEST_EXTRA_ARG(i, 'a');
+		{
+		  ui32_t length;
+		  Kumu::hex2bin(argv[i], asset_id_value, UUIDlen, &length);
+
+		  if ( length != UUIDlen )
+		    {
+		      fprintf(stderr, "Unexpected asset ID length: %u, expecting %u characters.\n", length, UUIDlen);
+		      return;
+		    }
+		}
+		break;
+
+	      case 'b':
+		TEST_EXTRA_ARG(i, 'b');
+		fb_size = Kumu::xabs(strtol(argv[i], 0, 10));
+
+		if ( verbose_flag )
+		  fprintf(stderr, "Frame Buffer size: %u bytes.\n", fb_size);
+
+		break;
+
+	      case 'c':
+		TEST_EXTRA_ARG(i, 'c');
+		mode = MMT_CREATE;
+		out_file = argv[i];
+		break;
+
+	      case 'd':
+		TEST_EXTRA_ARG(i, 'd');
+		duration_flag = true;
+		duration = Kumu::xabs(strtol(argv[i], 0, 10));
+		break;
+
+	      case 'E': encrypt_header_flag = false; break;
+	      case 'e': encrypt_header_flag = true; break;
+
+	      case 'f':
+		TEST_EXTRA_ARG(i, 'f');
+		start_frame = Kumu::xabs(strtol(argv[i], 0, 10));
+		break;
+
+	      case 'G': mode = MMT_GOP_START; break;
+	      case 'g': mode = MMT_GEN_KEY; break;
+	      case 'H': showheader_flag = true; break;
+	      case 'h': help_flag = true; break;
+	      case 'i': mode = MMT_INFO;	break;
+
+	      case 'j': key_id_flag = true;
+		TEST_EXTRA_ARG(i, 'j');
+		{
+		  ui32_t length;
+		  Kumu::hex2bin(argv[i], key_id_value, UUIDlen, &length);
+
+		  if ( length != UUIDlen )
+		    {
+		      fprintf(stderr, "Unexpected key ID length: %u, expecting %u characters.\n", length, UUIDlen);
+		      return;
+		    }
+		}
+		break;
+
+	      case 'k': key_flag = true;
+		TEST_EXTRA_ARG(i, 'k');
+		{
+		  ui32_t length;
+		  Kumu::hex2bin(argv[i], key_value, KeyLen, &length);
+
+		  if ( length != KeyLen )
+		    {
+		      fprintf(stderr, "Unexpected key length: %u, expecting %u characters.\n", length, KeyLen);
+		      return;
+		    }
+		}
+		break;
+
+	      case 'l':
+		TEST_EXTRA_ARG(i, 'l');
+		channel_fmt = decode_channel_fmt(argv[i]);
+		break;
+
+	      case 'L': use_smpte_labels = true; break;
+	      case 'M': write_hmac = false; break;
+	      case 'm': read_hmac = true; break;
+	      case 'n': showindex_flag = true; break;
+
+	      case 'p':
+		TEST_EXTRA_ARG(i, 'p');
+		picture_rate = Kumu::xabs(strtol(argv[i], 0, 10));
+		break;
+
+	      case 'R': do_repeat = true; break;
+	      case 'S': split_wav = true; break;
+
+	      case 's':
+		TEST_EXTRA_ARG(i, 's');
+		fb_dump_size = Kumu::xabs(strtol(argv[i], 0, 10));
+		break;
+
+	      case 't': mode = MMT_DIGEST; break;
+	      case 'U':	mode = MMT_UL_LIST; break;
+	      case 'u':	mode = MMT_GEN_ID; break;
+	      case 'V': version_flag = true; break;
+	      case 'v': verbose_flag = true; break;
+	      case 'W': no_write_flag = true; break;
+
+	      case 'w':
+		TEST_EXTRA_ARG(i, 'w');
+		number_width = Kumu::xabs(strtol(argv[i], 0, 10));
+		break;
+
+	      case 'x':
+		TEST_EXTRA_ARG(i, 'x');
+		mode = MMT_EXTRACT;
+		file_root = argv[i];
+		break;
+
+	      case 'Z': j2c_pedantic = false; break;
+	      case 'z': j2c_pedantic = true; break;
+
+	      default:
+		fprintf(stderr, "Unrecognized option: %s\n", argv[i]);
+		return;
+	      }
+	  }
+	else
+	  {
+
+	    if ( argv[i][0] != '-' )
+	      {
+		filenames[file_count++] = argv[i];
+	      }
+	    else
+	      {
+		fprintf(stderr, "Unrecognized argument: %s\n", argv[i]);
+		return;
+	      }
+
+	    if ( file_count >= MAX_IN_FILES )
+	      {
+		fprintf(stderr, "Filename lists exceeds maximum list size: %u\n", MAX_IN_FILES);
+		return;
+	      }
+	  }
+      }
+
+    if ( help_flag || version_flag )
+      return;
+    
+    if ( ( mode == MMT_INFO
+	   || mode == MMT_CREATE
+	   || mode == MMT_EXTRACT
+	   || mode == MMT_GOP_START
+	   || mode == MMT_DIGEST ) && file_count == 0 )
+      {
+	fputs("Option requires at least one filename argument.\n", stderr);
+	return;
+      }
+
+    if ( mode == MMT_NONE && ! help_flag && ! version_flag )
+      {
+	fputs("No operation selected (use one of -[gGcitux] or -h for help).\n", stderr);
+	return;
+      }
+
+    error_flag = false;
+  }
+};
+
+//------------------------------------------------------------------------------------------
+// MPEG2 essence
+
+// Write a plaintext MPEG2 Video Elementary Stream to a plaintext ASDCP file
+// Write a plaintext MPEG2 Video Elementary Stream to a ciphertext ASDCP file
+//
+Result_t
+write_MPEG2_file(CommandOptions& Options)
+{
+  AESEncContext*     Context = 0;
+  HMACContext*       HMAC = 0;
+  MPEG2::FrameBuffer FrameBuffer(Options.fb_size);
+  MPEG2::Parser      Parser;
+  MPEG2::MXFWriter   Writer;
+  MPEG2::VideoDescriptor VDesc;
+  byte_t             IV_buf[CBC_BLOCK_SIZE];
+  Kumu::FortunaRNG   RNG;
+
+  // set up essence parser
+  Result_t result = Parser.OpenRead(Options.filenames[0]);
+
+  // set up MXF writer
+  if ( ASDCP_SUCCESS(result) )
+    {
+      Parser.FillVideoDescriptor(VDesc);
+
+      if ( Options.verbose_flag )
+	{
+	  fputs("MPEG-2 Pictures\n", stderr);
+	  fputs("VideoDescriptor:\n", stderr);
+	  fprintf(stderr, "Frame Buffer size: %u\n", Options.fb_size);
+	  MPEG2::VideoDescriptorDump(VDesc);
+	}
+    }
+
+  if ( ASDCP_SUCCESS(result) && ! Options.no_write_flag )
+    {
+      WriterInfo Info = s_MyInfo;  // fill in your favorite identifiers here
+      if ( Options.asset_id_flag )
+	memcpy(Info.AssetUUID, Options.asset_id_value, UUIDlen);
+      else
+	Kumu::GenRandomUUID(Info.AssetUUID);
+
+      if ( Options.use_smpte_labels )
+	{
+	  Info.LabelSetType = LS_MXF_SMPTE;
+	  fprintf(stderr, "ATTENTION! Writing SMPTE Universal Labels\n");
+	}
+
+      // configure encryption
+      if( Options.key_flag )
+	{
+	  Kumu::GenRandomUUID(Info.ContextID);
+	  Info.EncryptedEssence = true;
+
+	  if ( Options.key_id_flag )
+	    memcpy(Info.CryptographicKeyID, Options.key_id_value, UUIDlen);
+	  else
+	    RNG.FillRandom(Info.CryptographicKeyID, UUIDlen);
+
+	  Context = new AESEncContext;
+	  result = Context->InitKey(Options.key_value);
+
+	  if ( ASDCP_SUCCESS(result) )
+	    result = Context->SetIVec(RNG.FillRandom(IV_buf, CBC_BLOCK_SIZE));
+
+	  if ( ASDCP_SUCCESS(result) && Options.write_hmac )
+	    {
+	      Info.UsesHMAC = true;
+	      HMAC = new HMACContext;
+	      result = HMAC->InitKey(Options.key_value, Info.LabelSetType);
+	    }
+	}
+
+      if ( ASDCP_SUCCESS(result) )
+	result = Writer.OpenWrite(Options.out_file, Info, VDesc);
+    }
+
+  if ( ASDCP_SUCCESS(result) )
+    // loop through the frames
+    {
+      result = Parser.Reset();
+      ui32_t duration = 0;
+
+      while ( ASDCP_SUCCESS(result) && duration++ < Options.duration )
+	{
+	  if ( ! Options.do_repeat || duration == 1 )
+	    {
+	      result = Parser.ReadFrame(FrameBuffer);
+
+	      if ( ASDCP_SUCCESS(result) )
+		{
+		  if ( Options.verbose_flag )
+		    FrameBuffer.Dump(stderr, Options.fb_dump_size);
+		  
+		  if ( Options.encrypt_header_flag )
+		    FrameBuffer.PlaintextOffset(0);
+		}
+	    }
+
+	  if ( ASDCP_SUCCESS(result) && ! Options.no_write_flag )
+	    {
+	      result = Writer.WriteFrame(FrameBuffer, Context, HMAC);
+
+	      // The Writer class will forward the last block of ciphertext
+	      // to the encryption context for use as the IV for the next
+	      // frame. If you want to use non-sequitur IV values, un-comment
+	      // the following  line of code.
+	      // if ( ASDCP_SUCCESS(result) && Options.key_flag )
+	      //   Context->SetIVec(RNG.FillRandom(IV_buf, CBC_BLOCK_SIZE));
+	    }
+	}
+
+      if ( result == RESULT_ENDOFFILE )
+	result = RESULT_OK;
+    }
+
+  if ( ASDCP_SUCCESS(result) && ! Options.no_write_flag )
+    result = Writer.Finalize();
+
+  return result;
+}
+
+// Read a plaintext MPEG2 Video Elementary Stream from a plaintext ASDCP file
+// Read a plaintext MPEG2 Video Elementary Stream from a ciphertext ASDCP file
+// Read a ciphertext MPEG2 Video Elementary Stream from a ciphertext ASDCP file
+//
+Result_t
+read_MPEG2_file(CommandOptions& Options)
+{
+  AESDecContext*     Context = 0;
+  HMACContext*       HMAC = 0;
+  MPEG2::MXFReader   Reader;
+  MPEG2::FrameBuffer FrameBuffer(Options.fb_size);
+  Kumu::FileWriter   OutFile;
+  ui32_t             frame_count = 0;
+
+  Result_t result = Reader.OpenRead(Options.filenames[0]);
+
+  if ( ASDCP_SUCCESS(result) )
+    {
+      MPEG2::VideoDescriptor VDesc;
+      Reader.FillVideoDescriptor(VDesc);
+      frame_count = VDesc.ContainerDuration;
+
+      if ( Options.verbose_flag )
+	{
+	  fprintf(stderr, "Frame Buffer size: %u\n", Options.fb_size);
+	  MPEG2::VideoDescriptorDump(VDesc);
+	}
+    }
+
+  if ( ASDCP_SUCCESS(result) )
+    {
+      char filename[256];
+      snprintf(filename, 256, "%s.ves", Options.file_root);
+      result = OutFile.OpenWrite(filename);
+    }
+
+  if ( ASDCP_SUCCESS(result) && Options.key_flag )
+    {
+      Context = new AESDecContext;
+      result = Context->InitKey(Options.key_value);
+
+      if ( ASDCP_SUCCESS(result) && Options.read_hmac )
+	{
+	  WriterInfo Info;
+	  Reader.FillWriterInfo(Info);
+
+	  if ( Info.UsesHMAC )
+	    {
+	      HMAC = new HMACContext;
+	      result = HMAC->InitKey(Options.key_value, Info.LabelSetType);
+	    }
+	  else
+	    {
+	      fputs("File does not contain HMAC values, ignoring -m option.\n", stderr);
+	    }
+	}
+    }
+
+  ui32_t last_frame = Options.start_frame + ( Options.duration ? Options.duration : frame_count);
+  if ( last_frame > frame_count )
+    last_frame = frame_count;
+
+  for ( ui32_t i = Options.start_frame; ASDCP_SUCCESS(result) && i < last_frame; i++ )
+    {
+      result = Reader.ReadFrame(i, FrameBuffer, Context, HMAC);
+
+      if ( ASDCP_SUCCESS(result) )
+	{
+	  if ( Options.verbose_flag )
+	    FrameBuffer.Dump(stderr, Options.fb_dump_size);
+
+	  ui32_t write_count = 0;
+	  result = OutFile.Write(FrameBuffer.Data(), FrameBuffer.Size(), &write_count);
+	}
+    }
+
+  return result;
+}
+
+
+//
+Result_t
+gop_start_test(CommandOptions& Options)
+{
+  using namespace ASDCP::MPEG2;
+
+  MXFReader   Reader;
+  MPEG2::FrameBuffer FrameBuffer(Options.fb_size);
+  ui32_t      frame_count = 0;
+
+  Result_t result = Reader.OpenRead(Options.filenames[0]);
+
+  if ( ASDCP_SUCCESS(result) )
+    {
+      MPEG2::VideoDescriptor VDesc;
+      Reader.FillVideoDescriptor(VDesc);
+      frame_count = VDesc.ContainerDuration;
+
+      if ( Options.verbose_flag )
+	{
+	  fprintf(stderr, "Frame Buffer size: %u\n", Options.fb_size);
+	  MPEG2::VideoDescriptorDump(VDesc);
+	}
+    }
+
+  ui32_t last_frame = Options.start_frame + ( Options.duration ? Options.duration : frame_count);
+  if ( last_frame > frame_count )
+    last_frame = frame_count;
+
+  for ( ui32_t i = Options.start_frame; ASDCP_SUCCESS(result) && i < last_frame; i++ )
+    {
+      result = Reader.ReadFrameGOPStart(i, FrameBuffer);
+
+      if ( ASDCP_SUCCESS(result) )
+	{
+	  if ( Options.verbose_flag )
+	    FrameBuffer.Dump(stderr, Options.fb_dump_size);
+
+	  if ( FrameBuffer.FrameType() != FRAME_I )
+	    fprintf(stderr, "Expecting an I frame, got %c\n", FrameTypeChar(FrameBuffer.FrameType()));
+
+	  fprintf(stderr, "Requested frame %u, got %u\n", i, FrameBuffer.FrameNumber());
+	}
+    }
+
+  return result;
+}
+
+//------------------------------------------------------------------------------------------
+// JPEG 2000 essence
+
+// Write one or more plaintext JPEG 2000 stereoscopic codestream pairs to a plaintext ASDCP file
+// Write one or more plaintext JPEG 2000 stereoscopic codestream pairs to a ciphertext ASDCP file
+//
+Result_t
+write_JP2K_S_file(CommandOptions& Options)
+{
+  AESEncContext*          Context = 0;
+  HMACContext*            HMAC = 0;
+  JP2K::MXFSWriter        Writer;
+  JP2K::FrameBuffer       FrameBuffer(Options.fb_size);
+  JP2K::PictureDescriptor PDesc;
+  JP2K::SequenceParser    ParserLeft, ParserRight;
+  byte_t                  IV_buf[CBC_BLOCK_SIZE];
+  Kumu::FortunaRNG        RNG;
+
+  if ( Options.file_count != 2 )
+    {
+      fprintf(stderr, "Two inputs are required for stereoscopic option.\n");
+      return RESULT_FAIL;
+    }
+
+  // set up essence parser
+  Result_t result = ParserLeft.OpenRead(Options.filenames[0], Options.j2c_pedantic);
+
+  if ( ASDCP_SUCCESS(result) )
+    result = ParserRight.OpenRead(Options.filenames[1], Options.j2c_pedantic);
+
+  // set up MXF writer
+  if ( ASDCP_SUCCESS(result) )
+    {
+      ParserLeft.FillPictureDescriptor(PDesc);
+      PDesc.EditRate = Options.PictureRate();
+
+      if ( Options.verbose_flag )
+	{
+	  fputs("JPEG 2000 stereoscopic pictures\nPictureDescriptor:\n", stderr);
+          fprintf(stderr, "Frame Buffer size: %u\n", Options.fb_size);
+	  JP2K::PictureDescriptorDump(PDesc);
+	}
+    }
+
+  if ( ASDCP_SUCCESS(result) && ! Options.no_write_flag )
+    {
+      WriterInfo Info = s_MyInfo;  // fill in your favorite identifiers here
+      if ( Options.asset_id_flag )
+	memcpy(Info.AssetUUID, Options.asset_id_value, UUIDlen);
+      else
+	Kumu::GenRandomUUID(Info.AssetUUID);
+
+      if ( Options.use_smpte_labels )
+	{
+	  Info.LabelSetType = LS_MXF_SMPTE;
+	  fprintf(stderr, "ATTENTION! Writing SMPTE Universal Labels\n");
+	}
+
+      // configure encryption
+      if( Options.key_flag )
+	{
+	  Kumu::GenRandomUUID(Info.ContextID);
+	  Info.EncryptedEssence = true;
+
+	  if ( Options.key_id_flag )
+	    memcpy(Info.CryptographicKeyID, Options.key_id_value, UUIDlen);
+	  else
+	    RNG.FillRandom(Info.CryptographicKeyID, UUIDlen);
+
+	  Context = new AESEncContext;
+	  result = Context->InitKey(Options.key_value);
+
+	  if ( ASDCP_SUCCESS(result) )
+	    result = Context->SetIVec(RNG.FillRandom(IV_buf, CBC_BLOCK_SIZE));
+
+	  if ( ASDCP_SUCCESS(result) && Options.write_hmac )
+	    {
+	      Info.UsesHMAC = true;
+	      HMAC = new HMACContext;
+	      result = HMAC->InitKey(Options.key_value, Info.LabelSetType);
+	    }
+	}
+
+      if ( ASDCP_SUCCESS(result) )
+	result = Writer.OpenWrite(Options.out_file, Info, PDesc);
+    }
+
+  if ( ASDCP_SUCCESS(result) )
+    {
+      ui32_t duration = 0;
+      result = ParserLeft.Reset();
+      if ( ASDCP_SUCCESS(result) ) result = ParserRight.Reset();
+
+      while ( ASDCP_SUCCESS(result) && duration++ < Options.duration )
+	{
+	  result = ParserLeft.ReadFrame(FrameBuffer);
+
+	  if ( ASDCP_SUCCESS(result) )
+	    {
+	      if ( Options.verbose_flag )
+		FrameBuffer.Dump(stderr, Options.fb_dump_size);
+		  
+	      if ( Options.encrypt_header_flag )
+		FrameBuffer.PlaintextOffset(0);
+	    }
+
+	  if ( ASDCP_SUCCESS(result) && ! Options.no_write_flag )
+	    result = Writer.WriteFrame(FrameBuffer, JP2K::SP_LEFT, Context, HMAC);
+
+	  if ( ASDCP_SUCCESS(result) )
+	    result = ParserRight.ReadFrame(FrameBuffer);
+
+	  if ( ASDCP_SUCCESS(result) )
+	    {
+	      if ( Options.verbose_flag )
+		FrameBuffer.Dump(stderr, Options.fb_dump_size);
+		  
+	      if ( Options.encrypt_header_flag )
+		FrameBuffer.PlaintextOffset(0);
+	    }
+
+	  if ( ASDCP_SUCCESS(result) && ! Options.no_write_flag )
+	    result = Writer.WriteFrame(FrameBuffer, JP2K::SP_RIGHT, Context, HMAC);
+	}
+
+      if ( result == RESULT_ENDOFFILE )
+	result = RESULT_OK;
+    }
+
+  if ( ASDCP_SUCCESS(result) && ! Options.no_write_flag )
+    result = Writer.Finalize();
+
+  return result;
+}
+
+// Read one or more plaintext JPEG 2000 stereoscopic codestream pairs from a plaintext ASDCP file
+// Read one or more plaintext JPEG 2000 stereoscopic codestream pairs from a ciphertext ASDCP file
+// Read one or more ciphertext JPEG 2000 stereoscopic codestream pairs from a ciphertext ASDCP file
+Result_t
+read_JP2K_S_file(CommandOptions& Options)
+{
+  AESDecContext*     Context = 0;
+  HMACContext*       HMAC = 0;
+  JP2K::MXFSReader    Reader;
+  JP2K::FrameBuffer  FrameBuffer(Options.fb_size);
+  ui32_t             frame_count = 0;
+
+  Result_t result = Reader.OpenRead(Options.filenames[0]);
+
+  if ( ASDCP_SUCCESS(result) )
+    {
+      JP2K::PictureDescriptor PDesc;
+      Reader.FillPictureDescriptor(PDesc);
+
+      frame_count = PDesc.ContainerDuration;
+
+      if ( Options.verbose_flag )
+	{
+	  fprintf(stderr, "Frame Buffer size: %u\n", Options.fb_size);
+	  JP2K::PictureDescriptorDump(PDesc);
+	}
+    }
+
+  if ( ASDCP_SUCCESS(result) && Options.key_flag )
+    {
+      Context = new AESDecContext;
+      result = Context->InitKey(Options.key_value);
+
+      if ( ASDCP_SUCCESS(result) && Options.read_hmac )
+	{
+	  WriterInfo Info;
+	  Reader.FillWriterInfo(Info);
+
+	  if ( Info.UsesHMAC )
+	    {
+	      HMAC = new HMACContext;
+	      result = HMAC->InitKey(Options.key_value, Info.LabelSetType);
+	    }
+	  else
+	    {
+	      fputs("File does not contain HMAC values, ignoring -m option.\n", stderr);
+	    }
+	}
+    }
+
+  const int filename_max = 1024;
+  char filename[filename_max];
+  ui32_t last_frame = Options.start_frame + ( Options.duration ? Options.duration : frame_count);
+  if ( last_frame > frame_count )
+    last_frame = frame_count;
+
+  char left_format[64];  char right_format[64];
+  snprintf(left_format,  64, "%%s%%0%duL.j2c", Options.number_width);
+  snprintf(right_format, 64, "%%s%%0%duR.j2c", Options.number_width);
+
+  for ( ui32_t i = Options.start_frame; ASDCP_SUCCESS(result) && i < last_frame; i++ )
+    {
+      result = Reader.ReadFrame(i, JP2K::SP_LEFT, FrameBuffer, Context, HMAC);
+
+      if ( ASDCP_SUCCESS(result) )
+	{
+	  Kumu::FileWriter OutFile;
+	  ui32_t write_count;
+	  snprintf(filename, filename_max, left_format, Options.file_root, i);
+	  result = OutFile.OpenWrite(filename);
+
+	  if ( ASDCP_SUCCESS(result) )
+	    result = OutFile.Write(FrameBuffer.Data(), FrameBuffer.Size(), &write_count);
+
+	  if ( Options.verbose_flag )
+	    FrameBuffer.Dump(stderr, Options.fb_dump_size);
+	}
+
+      if ( ASDCP_SUCCESS(result) )
+	result = Reader.ReadFrame(i, JP2K::SP_RIGHT, FrameBuffer, Context, HMAC);
+
+      if ( ASDCP_SUCCESS(result) )
+	{
+	  Kumu::FileWriter OutFile;
+	  ui32_t write_count;
+	  snprintf(filename, filename_max, right_format, Options.file_root, i);
+	  result = OutFile.OpenWrite(filename);
+
+	  if ( ASDCP_SUCCESS(result) )
+	    result = OutFile.Write(FrameBuffer.Data(), FrameBuffer.Size(), &write_count);
+	}
+    }
+
+  return result;
+}
+
+
+
+// Write one or more plaintext JPEG 2000 codestreams to a plaintext ASDCP file
+// Write one or more plaintext JPEG 2000 codestreams to a ciphertext ASDCP file
+//
+Result_t
+write_JP2K_file(CommandOptions& Options)
+{
+  AESEncContext*          Context = 0;
+  HMACContext*            HMAC = 0;
+  JP2K::MXFWriter         Writer;
+  JP2K::FrameBuffer       FrameBuffer(Options.fb_size);
+  JP2K::PictureDescriptor PDesc;
+  JP2K::SequenceParser    Parser;
+  byte_t                  IV_buf[CBC_BLOCK_SIZE];
+  Kumu::FortunaRNG        RNG;
+
+  // set up essence parser
+  Result_t result = Parser.OpenRead(Options.filenames[0], Options.j2c_pedantic);
+
+  // set up MXF writer
+  if ( ASDCP_SUCCESS(result) )
+    {
+      Parser.FillPictureDescriptor(PDesc);
+      PDesc.EditRate = Options.PictureRate();
+
+      if ( Options.verbose_flag )
+	{
+	  fprintf(stderr, "JPEG 2000 pictures\n");
+	  fputs("PictureDescriptor:\n", stderr);
+          fprintf(stderr, "Frame Buffer size: %u\n", Options.fb_size);
+	  JP2K::PictureDescriptorDump(PDesc);
+	}
+    }
+
+  if ( ASDCP_SUCCESS(result) && ! Options.no_write_flag )
+    {
+      WriterInfo Info = s_MyInfo;  // fill in your favorite identifiers here
+      if ( Options.asset_id_flag )
+	memcpy(Info.AssetUUID, Options.asset_id_value, UUIDlen);
+      else
+	Kumu::GenRandomUUID(Info.AssetUUID);
+
+      if ( Options.use_smpte_labels )
+	{
+	  Info.LabelSetType = LS_MXF_SMPTE;
+	  fprintf(stderr, "ATTENTION! Writing SMPTE Universal Labels\n");
+	}
+
+      // configure encryption
+      if( Options.key_flag )
+	{
+	  Kumu::GenRandomUUID(Info.ContextID);
+	  Info.EncryptedEssence = true;
+
+	  if ( Options.key_id_flag )
+	    memcpy(Info.CryptographicKeyID, Options.key_id_value, UUIDlen);
+	  else
+	    RNG.FillRandom(Info.CryptographicKeyID, UUIDlen);
+
+	  Context = new AESEncContext;
+	  result = Context->InitKey(Options.key_value);
+
+	  if ( ASDCP_SUCCESS(result) )
+	    result = Context->SetIVec(RNG.FillRandom(IV_buf, CBC_BLOCK_SIZE));
+
+	  if ( ASDCP_SUCCESS(result) && Options.write_hmac )
+	    {
+	      Info.UsesHMAC = true;
+	      HMAC = new HMACContext;
+	      result = HMAC->InitKey(Options.key_value, Info.LabelSetType);
+	    }
+	}
+
+      if ( ASDCP_SUCCESS(result) )
+	result = Writer.OpenWrite(Options.out_file, Info, PDesc);
+    }
+
+  if ( ASDCP_SUCCESS(result) )
+    {
+      ui32_t duration = 0;
+      result = Parser.Reset();
+
+      while ( ASDCP_SUCCESS(result) && duration++ < Options.duration )
+	{
+	  if ( ! Options.do_repeat || duration == 1 )
+	    {
+	      result = Parser.ReadFrame(FrameBuffer);
+
+	      if ( ASDCP_SUCCESS(result) )
+		{
+		  if ( Options.verbose_flag )
+		    FrameBuffer.Dump(stderr, Options.fb_dump_size);
+		  
+		  if ( Options.encrypt_header_flag )
+		    FrameBuffer.PlaintextOffset(0);
+		}
+	    }
+
+	  if ( ASDCP_SUCCESS(result) && ! Options.no_write_flag )
+	    {
+	      result = Writer.WriteFrame(FrameBuffer, Context, HMAC);
+
+	      // The Writer class will forward the last block of ciphertext
+	      // to the encryption context for use as the IV for the next
+	      // frame. If you want to use non-sequitur IV values, un-comment
+	      // the following  line of code.
+	      // if ( ASDCP_SUCCESS(result) && Options.key_flag )
+	      //   Context->SetIVec(RNG.FillRandom(IV_buf, CBC_BLOCK_SIZE));
+	    }
+	}
+
+      if ( result == RESULT_ENDOFFILE )
+	result = RESULT_OK;
+    }
+
+  if ( ASDCP_SUCCESS(result) && ! Options.no_write_flag )
+    result = Writer.Finalize();
+
+  return result;
+}
+
+// Read one or more plaintext JPEG 2000 codestreams from a plaintext ASDCP file
+// Read one or more plaintext JPEG 2000 codestreams from a ciphertext ASDCP file
+// Read one or more ciphertext JPEG 2000 codestreams from a ciphertext ASDCP file
+//
+Result_t
+read_JP2K_file(CommandOptions& Options)
+{
+  AESDecContext*     Context = 0;
+  HMACContext*       HMAC = 0;
+  JP2K::MXFReader    Reader;
+  JP2K::FrameBuffer  FrameBuffer(Options.fb_size);
+  ui32_t             frame_count = 0;
+
+  Result_t result = Reader.OpenRead(Options.filenames[0]);
+
+  if ( ASDCP_SUCCESS(result) )
+    {
+      JP2K::PictureDescriptor PDesc;
+      Reader.FillPictureDescriptor(PDesc);
+
+      frame_count = PDesc.ContainerDuration;
+
+      if ( Options.verbose_flag )
+	{
+	  fprintf(stderr, "Frame Buffer size: %u\n", Options.fb_size);
+	  JP2K::PictureDescriptorDump(PDesc);
+	}
+    }
+
+  if ( ASDCP_SUCCESS(result) && Options.key_flag )
+    {
+      Context = new AESDecContext;
+      result = Context->InitKey(Options.key_value);
+
+      if ( ASDCP_SUCCESS(result) && Options.read_hmac )
+	{
+	  WriterInfo Info;
+	  Reader.FillWriterInfo(Info);
+
+	  if ( Info.UsesHMAC )
+	    {
+	      HMAC = new HMACContext;
+	      result = HMAC->InitKey(Options.key_value, Info.LabelSetType);
+	    }
+	  else
+	    {
+	      fputs("File does not contain HMAC values, ignoring -m option.\n", stderr);
+	    }
+	}
+    }
+
+  ui32_t last_frame = Options.start_frame + ( Options.duration ? Options.duration : frame_count);
+  if ( last_frame > frame_count )
+    last_frame = frame_count;
+
+  char name_format[64];
+  snprintf(name_format,  64, "%%s%%0%du.j2c", Options.number_width);
+
+  for ( ui32_t i = Options.start_frame; ASDCP_SUCCESS(result) && i < last_frame; i++ )
+    {
+      result = Reader.ReadFrame(i, FrameBuffer, Context, HMAC);
+
+      if ( ASDCP_SUCCESS(result) )
+	{
+	  Kumu::FileWriter OutFile;
+	  char filename[256];
+	  ui32_t write_count;
+	  snprintf(filename, 256, name_format, Options.file_root, i);
+	  result = OutFile.OpenWrite(filename);
+
+	  if ( ASDCP_SUCCESS(result) )
+	    result = OutFile.Write(FrameBuffer.Data(), FrameBuffer.Size(), &write_count);
+
+	  if ( Options.verbose_flag )
+	    FrameBuffer.Dump(stderr, Options.fb_dump_size);
+	}
+    }
+
+  return result;
+}
+
+//------------------------------------------------------------------------------------------
+// PCM essence
+
+
+// Write one or more plaintext PCM audio streams to a plaintext ASDCP file
+// Write one or more plaintext PCM audio streams to a ciphertext ASDCP file
+//
+Result_t
+write_PCM_file(CommandOptions& Options)
+{
+  AESEncContext*    Context = 0;
+  HMACContext*      HMAC = 0;
+  PCMParserList     Parser;
+  PCM::MXFWriter    Writer;
+  PCM::FrameBuffer  FrameBuffer;
+  PCM::AudioDescriptor ADesc;
+  Rational          PictureRate = Options.PictureRate();
+  byte_t            IV_buf[CBC_BLOCK_SIZE];
+  Kumu::FortunaRNG  RNG;
+
+  // set up essence parser
+  Result_t result = Parser.OpenRead(Options.file_count, Options.filenames, PictureRate);
+
+  // set up MXF writer
+  if ( ASDCP_SUCCESS(result) )
+    {
+      Parser.FillAudioDescriptor(ADesc);
+
+      ADesc.EditRate = PictureRate;
+      FrameBuffer.Capacity(PCM::CalcFrameBufferSize(ADesc));
+      ADesc.ChannelFormat = Options.channel_fmt;
+
+      if ( Options.use_smpte_labels && ADesc.ChannelFormat == PCM::CF_NONE)
+	{
+	  fprintf(stderr, "ATTENTION! Writing SMPTE audio without ChannelAssignment property (see option -l)\n");
+	}
+
+      if ( Options.verbose_flag )
+	{
+	  fprintf(stderr, "%.1fkHz PCM Audio, %s fps (%u spf)\n",
+		  ADesc.AudioSamplingRate.Quotient() / 1000.0,
+		  Options.szPictureRate(),
+		  PCM::CalcSamplesPerFrame(ADesc));
+	  fputs("AudioDescriptor:\n", stderr);
+	  PCM::AudioDescriptorDump(ADesc);
+	}
+    }
+
+  if ( ASDCP_SUCCESS(result) && ! Options.no_write_flag )
+    {
+      WriterInfo Info = s_MyInfo;  // fill in your favorite identifiers here
+      if ( Options.asset_id_flag )
+	memcpy(Info.AssetUUID, Options.asset_id_value, UUIDlen);
+      else
+	Kumu::GenRandomUUID(Info.AssetUUID);
+
+      if ( Options.use_smpte_labels )
+	{
+	  Info.LabelSetType = LS_MXF_SMPTE;
+	  fprintf(stderr, "ATTENTION! Writing SMPTE Universal Labels\n");
+	}
+
+      // configure encryption
+      if( Options.key_flag )
+	{
+	  Kumu::GenRandomUUID(Info.ContextID);
+	  Info.EncryptedEssence = true;
+
+	  if ( Options.key_id_flag )
+	    memcpy(Info.CryptographicKeyID, Options.key_id_value, UUIDlen);
+	  else
+	    RNG.FillRandom(Info.CryptographicKeyID, UUIDlen);
+
+	  Context = new AESEncContext;
+	  result = Context->InitKey(Options.key_value);
+
+	  if ( ASDCP_SUCCESS(result) )
+	    result = Context->SetIVec(RNG.FillRandom(IV_buf, CBC_BLOCK_SIZE));
+
+	  if ( ASDCP_SUCCESS(result) && Options.write_hmac )
+	    {
+	      Info.UsesHMAC = true;
+	      HMAC = new HMACContext;
+	      result = HMAC->InitKey(Options.key_value, Info.LabelSetType);
+	    }
+	}
+
+      if ( ASDCP_SUCCESS(result) )
+	result = Writer.OpenWrite(Options.out_file, Info, ADesc);
+    }
+
+  if ( ASDCP_SUCCESS(result) )
+    {
+      result = Parser.Reset();
+      ui32_t duration = 0;
+
+      while ( ASDCP_SUCCESS(result) && duration++ < Options.duration )
+	{
+	  result = Parser.ReadFrame(FrameBuffer);
+
+	  if ( ASDCP_SUCCESS(result) )
+	    {
+	      if ( FrameBuffer.Size() != FrameBuffer.Capacity() )
+		{
+		  fprintf(stderr, "WARNING: Last frame read was short, PCM input is possibly not frame aligned.\n");
+		  fprintf(stderr, "Expecting %u bytes, got %u.\n", FrameBuffer.Capacity(), FrameBuffer.Size());
+		  result = RESULT_ENDOFFILE;
+		  continue;
+		}
+
+	      if ( Options.verbose_flag )
+		FrameBuffer.Dump(stderr, Options.fb_dump_size);
+
+	      if ( ! Options.no_write_flag )
+		{
+		  result = Writer.WriteFrame(FrameBuffer, Context, HMAC);
+
+		  // The Writer class will forward the last block of ciphertext
+		  // to the encryption context for use as the IV for the next
+		  // frame. If you want to use non-sequitur IV values, un-comment
+		  // the following  line of code.
+		  // if ( ASDCP_SUCCESS(result) && Options.key_flag )
+		  //   Context->SetIVec(RNG.FillRandom(IV_buf, CBC_BLOCK_SIZE));
+		}
+	    }
+	}
+
+      if ( result == RESULT_ENDOFFILE )
+	result = RESULT_OK;
+    }
+
+  if ( ASDCP_SUCCESS(result) && ! Options.no_write_flag )
+    result = Writer.Finalize();
+
+  return result;
+}
+
+// Read one or more plaintext PCM audio streams from a plaintext ASDCP file
+// Read one or more plaintext PCM audio streams from a ciphertext ASDCP file
+// Read one or more ciphertext PCM audio streams from a ciphertext ASDCP file
+//
+Result_t
+read_PCM_file(CommandOptions& Options)
+{
+  AESDecContext*     Context = 0;
+  HMACContext*       HMAC = 0;
+  PCM::MXFReader     Reader;
+  PCM::FrameBuffer   FrameBuffer;
+  WavFileWriter      OutWave;
+  PCM::AudioDescriptor ADesc;
+  ui32_t last_frame = 0;
+
+  Result_t result = Reader.OpenRead(Options.filenames[0]);
+
+  if ( ASDCP_SUCCESS(result) )
+    {
+      Reader.FillAudioDescriptor(ADesc);
+
+      if ( ADesc.EditRate != EditRate_23_98
+	   && ADesc.EditRate != EditRate_24
+	   && ADesc.EditRate != EditRate_25
+	   && ADesc.EditRate != EditRate_30
+	   && ADesc.EditRate != EditRate_48
+	   && ADesc.EditRate != EditRate_50
+	   && ADesc.EditRate != EditRate_60 )
+	ADesc.EditRate = Options.PictureRate();
+
+      FrameBuffer.Capacity(PCM::CalcFrameBufferSize(ADesc));
+
+      if ( Options.verbose_flag )
+	PCM::AudioDescriptorDump(ADesc);
+    }
+
+  if ( ASDCP_SUCCESS(result) )
+    {
+      last_frame = ADesc.ContainerDuration;
+
+      if ( Options.duration > 0 && Options.duration < last_frame )
+	last_frame = Options.duration;
+
+      if ( Options.start_frame > 0 )
+	{
+	  if ( Options.start_frame > ADesc.ContainerDuration )
+	    {
+	      fprintf(stderr, "Start value greater than file duration.\n");
+	      return RESULT_FAIL;
+	    }
+
+	  last_frame = Kumu::xmin(Options.start_frame + last_frame, ADesc.ContainerDuration);
+	}
+
+      ADesc.ContainerDuration = last_frame - Options.start_frame;
+      OutWave.OpenWrite(ADesc, Options.file_root,
+			( Options.split_wav ? WavFileWriter::ST_STEREO : 
+			  ( Options.mono_wav ? WavFileWriter::ST_MONO : WavFileWriter::ST_NONE ) ));
+    }
+
+  if ( ASDCP_SUCCESS(result) && Options.key_flag )
+    {
+      Context = new AESDecContext;
+      result = Context->InitKey(Options.key_value);
+
+      if ( ASDCP_SUCCESS(result) && Options.read_hmac )
+	{
+	  WriterInfo Info;
+	  Reader.FillWriterInfo(Info);
+
+	  if ( Info.UsesHMAC )
+	    {
+	      HMAC = new HMACContext;
+	      result = HMAC->InitKey(Options.key_value, Info.LabelSetType);
+	    }
+	  else
+	    {
+	      fputs("File does not contain HMAC values, ignoring -m option.\n", stderr);
+	    }
+	}
+    }
+
+  for ( ui32_t i = Options.start_frame; ASDCP_SUCCESS(result) && i < last_frame; i++ )
+    {
+      result = Reader.ReadFrame(i, FrameBuffer, Context, HMAC);
+
+      if ( ASDCP_SUCCESS(result) )
+	{
+	  if ( Options.verbose_flag )
+	    FrameBuffer.Dump(stderr, Options.fb_dump_size);
+
+	  result = OutWave.WriteFrame(FrameBuffer);
+	}
+    }
+
+  return result;
+}
+
+
+//------------------------------------------------------------------------------------------
+// TimedText essence
+
+
+// Write one or more plaintext timed text streams to a plaintext ASDCP file
+// Write one or more plaintext timed text streams to a ciphertext ASDCP file
+//
+Result_t
+write_timed_text_file(CommandOptions& Options)
+{
+  AESEncContext*    Context = 0;
+  HMACContext*      HMAC = 0;
+  TimedText::DCSubtitleParser  Parser;
+  TimedText::MXFWriter    Writer;
+  TimedText::FrameBuffer  FrameBuffer;
+  TimedText::TimedTextDescriptor TDesc;
+  byte_t            IV_buf[CBC_BLOCK_SIZE];
+  Kumu::FortunaRNG  RNG;
+
+  // set up essence parser
+  Result_t result = Parser.OpenRead(Options.filenames[0]);
+
+  // set up MXF writer
+  if ( ASDCP_SUCCESS(result) )
+    {
+      Parser.FillTimedTextDescriptor(TDesc);
+      FrameBuffer.Capacity(Options.fb_size);
+
+      if ( Options.verbose_flag )
+	{
+	  fputs("D-Cinema Timed-Text Descriptor:\n", stderr);
+	  TimedText::DescriptorDump(TDesc);
+	}
+    }
+
+  if ( ASDCP_SUCCESS(result) && ! Options.no_write_flag )
+    {
+      WriterInfo Info = s_MyInfo;  // fill in your favorite identifiers here
+      if ( Options.asset_id_flag )
+	memcpy(Info.AssetUUID, Options.asset_id_value, UUIDlen);
+      else
+	Kumu::GenRandomUUID(Info.AssetUUID);
+
+      if ( Options.use_smpte_labels )
+	{
+	  Info.LabelSetType = LS_MXF_SMPTE;
+	  fprintf(stderr, "ATTENTION! Writing SMPTE Universal Labels\n");
+	}
+
+      // configure encryption
+      if( Options.key_flag )
+	{
+	  Kumu::GenRandomUUID(Info.ContextID);
+	  Info.EncryptedEssence = true;
+
+	  if ( Options.key_id_flag )
+	    memcpy(Info.CryptographicKeyID, Options.key_id_value, UUIDlen);
+	  else
+	    RNG.FillRandom(Info.CryptographicKeyID, UUIDlen);
+
+	  Context = new AESEncContext;
+	  result = Context->InitKey(Options.key_value);
+
+	  if ( ASDCP_SUCCESS(result) )
+	    result = Context->SetIVec(RNG.FillRandom(IV_buf, CBC_BLOCK_SIZE));
+
+	  if ( ASDCP_SUCCESS(result) && Options.write_hmac )
+	    {
+	      Info.UsesHMAC = true;
+	      HMAC = new HMACContext;
+	      result = HMAC->InitKey(Options.key_value, Info.LabelSetType);
+	    }
+	}
+
+      if ( ASDCP_SUCCESS(result) )
+	result = Writer.OpenWrite(Options.out_file, Info, TDesc);
+    }
+
+  if ( ASDCP_FAILURE(result) )
+    return result;
+
+  std::string XMLDoc;
+  TimedText::ResourceList_t::const_iterator ri;
+
+  result = Parser.ReadTimedTextResource(XMLDoc);
+
+  if ( ASDCP_SUCCESS(result) )
+    result = Writer.WriteTimedTextResource(XMLDoc, Context, HMAC);
+
+  for ( ri = TDesc.ResourceList.begin() ; ri != TDesc.ResourceList.end() && ASDCP_SUCCESS(result); ri++ )
+    {
+      result = Parser.ReadAncillaryResource((*ri).ResourceID, FrameBuffer);
+
+      if ( ASDCP_SUCCESS(result) )
+	{
+	  if ( Options.verbose_flag )
+	    FrameBuffer.Dump(stderr, Options.fb_dump_size);
+
+	  if ( ! Options.no_write_flag )
+	    {
+	      result = Writer.WriteAncillaryResource(FrameBuffer, Context, HMAC);
+	      
+	      // The Writer class will forward the last block of ciphertext
+	      // to the encryption context for use as the IV for the next
+	      // frame. If you want to use non-sequitur IV values, un-comment
+	      // the following  line of code.
+	      // if ( ASDCP_SUCCESS(result) && Options.key_flag )
+	      //   Context->SetIVec(RNG.FillRandom(IV_buf, CBC_BLOCK_SIZE));
+	    }
+	}
+
+      if ( result == RESULT_ENDOFFILE )
+	result = RESULT_OK;
+    }
+
+  if ( ASDCP_SUCCESS(result) && ! Options.no_write_flag )
+    result = Writer.Finalize();
+
+  return result;
+}
+
+
+// Read one or more timed text streams from a plaintext ASDCP file
+// Read one or more timed text streams from a ciphertext ASDCP file
+// Read one or more timed text streams from a ciphertext ASDCP file
+//
+Result_t
+read_timed_text_file(CommandOptions& Options)
+{
+  AESDecContext*     Context = 0;
+  HMACContext*       HMAC = 0;
+  TimedText::MXFReader     Reader;
+  TimedText::FrameBuffer   FrameBuffer;
+  TimedText::TimedTextDescriptor TDesc;
+
+  Result_t result = Reader.OpenRead(Options.filenames[0]);
+
+  if ( ASDCP_SUCCESS(result) )
+    {
+      Reader.FillTimedTextDescriptor(TDesc);
+      FrameBuffer.Capacity(Options.fb_size);
+
+      if ( Options.verbose_flag )
+	TimedText::DescriptorDump(TDesc);
+    }
+
+  if ( ASDCP_SUCCESS(result) && Options.key_flag )
+    {
+      Context = new AESDecContext;
+      result = Context->InitKey(Options.key_value);
+
+      if ( ASDCP_SUCCESS(result) && Options.read_hmac )
+	{
+	  WriterInfo Info;
+	  Reader.FillWriterInfo(Info);
+
+	  if ( Info.UsesHMAC )
+	    {
+	      HMAC = new HMACContext;
+	      result = HMAC->InitKey(Options.key_value, Info.LabelSetType);
+	    }
+	  else
+	    {
+	      fputs("File does not contain HMAC values, ignoring -m option.\n", stderr);
+	    }
+	}
+    }
+
+  if ( ASDCP_FAILURE(result) )
+    return result;
+
+  std::string XMLDoc;
+  std::string out_path = Kumu::PathDirname(Options.file_root);
+  ui32_t write_count;
+  char buf[64];
+  TimedText::ResourceList_t::const_iterator ri;
+
+  result = Reader.ReadTimedTextResource(XMLDoc, Context, HMAC);
+
+  if ( ASDCP_SUCCESS(result) )
+    {
+      Kumu::FileWriter Writer;
+      result = Writer.OpenWrite(Options.file_root);
+
+      if ( ASDCP_SUCCESS(result) )
+	result = Writer.Write(reinterpret_cast<const byte_t*>(XMLDoc.c_str()), XMLDoc.size(), &write_count);
+    }
+
+  for ( ri = TDesc.ResourceList.begin() ; ri != TDesc.ResourceList.end() && ASDCP_SUCCESS(result); ri++ )
+    {
+      result = Reader.ReadAncillaryResource(ri->ResourceID, FrameBuffer, Context, HMAC);
+
+      if ( ASDCP_SUCCESS(result) )
+	{
+	  Kumu::FileWriter Writer;
+	  result = Writer.OpenWrite(Kumu::PathJoin(out_path, Kumu::UUID(ri->ResourceID).EncodeHex(buf, 64)).c_str());
+
+	  if ( ASDCP_SUCCESS(result) )
+	    {
+	      if ( Options.verbose_flag )
+		FrameBuffer.Dump(stderr, Options.fb_dump_size);
+
+	      result = Writer.Write(FrameBuffer.RoData(), FrameBuffer.Size(), &write_count);
+	    }
+	}
+    }
+
+  return result;
+}
+
+//------------------------------------------------------------------------------------------
+//
+
+//
+// These classes wrap the irregular names in the asdcplib API
+// so that I can use a template to simplify the implementation
+// of show_file_info()
+
+class MyVideoDescriptor : public MPEG2::VideoDescriptor
+{
+ public:
+  void FillDescriptor(MPEG2::MXFReader& Reader) {
+    Reader.FillVideoDescriptor(*this);
+  }
+
+  void Dump(FILE* stream) {
+    MPEG2::VideoDescriptorDump(*this, stream);
+  }
+};
+
+class MyPictureDescriptor : public JP2K::PictureDescriptor
+{
+ public:
+  void FillDescriptor(JP2K::MXFReader& Reader) {
+    Reader.FillPictureDescriptor(*this);
+  }
+
+  void Dump(FILE* stream) {
+    JP2K::PictureDescriptorDump(*this, stream);
+  }
+};
+
+class MyStereoPictureDescriptor : public JP2K::PictureDescriptor
+{
+ public:
+  void FillDescriptor(JP2K::MXFSReader& Reader) {
+    Reader.FillPictureDescriptor(*this);
+  }
+
+  void Dump(FILE* stream) {
+    JP2K::PictureDescriptorDump(*this, stream);
+  }
+};
+
+class MyAudioDescriptor : public PCM::AudioDescriptor
+{
+ public:
+  void FillDescriptor(PCM::MXFReader& Reader) {
+    Reader.FillAudioDescriptor(*this);
+  }
+
+  void Dump(FILE* stream) {
+    PCM::AudioDescriptorDump(*this, stream);
+  }
+};
+
+class MyTextDescriptor : public TimedText::TimedTextDescriptor
+{
+ public:
+  void FillDescriptor(TimedText::MXFReader& Reader) {
+    Reader.FillTimedTextDescriptor(*this);
+  }
+
+  void Dump(FILE* stream) {
+    TimedText::DescriptorDump(*this, stream);
+  }
+};
+
+// MSVC didn't like the function template, so now it's a static class method
+template<class ReaderT, class DescriptorT>
+class FileInfoWrapper
+{
+public:
+  static Result_t
+  file_info(CommandOptions& Options, const char* type_string, FILE* stream = 0)
+  {
+    assert(type_string);
+    if ( stream == 0 )
+      stream = stdout;
+
+    Result_t result = RESULT_OK;
+
+    if ( Options.verbose_flag || Options.showheader_flag )
+      {
+	ReaderT     Reader;
+	result = Reader.OpenRead(Options.filenames[0]);
+
+	if ( ASDCP_SUCCESS(result) )
+	  {
+	    fprintf(stdout, "File essence type is %s.\n", type_string);
+
+	    if ( Options.showheader_flag )
+	      Reader.DumpHeaderMetadata(stream);
+
+	    WriterInfo WI;
+	    Reader.FillWriterInfo(WI);
+	    WriterInfoDump(WI, stream);
+
+	    DescriptorT Desc;
+	    Desc.FillDescriptor(Reader);
+	    Desc.Dump(stream);
+
+	    if ( Options.showindex_flag )
+	      Reader.DumpIndex(stream);
+	  }
+	else if ( result == RESULT_FORMAT && Options.showheader_flag )
+	  {
+	    Reader.DumpHeaderMetadata(stream);
+	  }
+      }
+
+    return result;
+  }
+};
+
+// Read header metadata from an ASDCP file
+//
+Result_t
+show_file_info(CommandOptions& Options)
+{
+  EssenceType_t EssenceType;
+  Result_t result = ASDCP::EssenceType(Options.filenames[0], EssenceType);
+
+  if ( ASDCP_FAILURE(result) )
+    return result;
+
+  if ( EssenceType == ESS_MPEG2_VES )
+    {
+      result = FileInfoWrapper<ASDCP::MPEG2::MXFReader, MyVideoDescriptor>::file_info(Options, "MPEG2 video");
+    }
+  else if ( EssenceType == ESS_PCM_24b_48k || EssenceType == ESS_PCM_24b_96k )
+    {
+      result = FileInfoWrapper<ASDCP::PCM::MXFReader, MyAudioDescriptor>::file_info(Options, "PCM audio");
+
+      if ( ASDCP_SUCCESS(result) )
+	{
+	  const Dictionary* Dict = &DefaultCompositeDict();
+	  PCM::MXFReader Reader;
+	  MXF::OP1aHeader Header(Dict);
+	  MXF::WaveAudioDescriptor *descriptor = 0;
+
+	  result = Reader.OpenRead(Options.filenames[0]);
+
+	  if ( ASDCP_SUCCESS(result) )
+	    result = Reader.OP1aHeader().GetMDObjectByType(Dict->ul(MDD_WaveAudioDescriptor), reinterpret_cast<MXF::InterchangeObject**>(&descriptor));
+
+	  if ( ASDCP_SUCCESS(result) )
+	    {
+	      char buf[64];
+	      fprintf(stdout, " ChannelAssignment: %s\n", descriptor->ChannelAssignment.const_get().EncodeString(buf, 64));
+	    }
+	}
+    }
+  else if ( EssenceType == ESS_JPEG_2000 )
+    {
+      if ( Options.stereo_image_flag )
+	{
+	  result = FileInfoWrapper<ASDCP::JP2K::MXFSReader,
+				   MyStereoPictureDescriptor>::file_info(Options, "JPEG 2000 stereoscopic pictures");
+	}
+      else
+	{
+	  result = FileInfoWrapper<ASDCP::JP2K::MXFReader,
+				   MyPictureDescriptor>::file_info(Options, "JPEG 2000 pictures");
+	}
+    }
+  else if ( EssenceType == ESS_JPEG_2000_S )
+    {
+      result = FileInfoWrapper<ASDCP::JP2K::MXFSReader,
+			       MyStereoPictureDescriptor>::file_info(Options, "JPEG 2000 stereoscopic pictures");
+    }
+  else if ( EssenceType == ESS_TIMED_TEXT )
+    {
+      result = FileInfoWrapper<ASDCP::TimedText::MXFReader, MyTextDescriptor>::file_info(Options, "Timed Text");
+    }
+  else
+    {
+      fprintf(stderr, "File is not AS-DCP: %s\n", Options.filenames[0]);
+      Kumu::FileReader   Reader;
+      const Dictionary* Dict = &DefaultCompositeDict();
+      MXF::OP1aHeader TestHeader(Dict);
+
+      result = Reader.OpenRead(Options.filenames[0]);
+
+      if ( ASDCP_SUCCESS(result) )
+	result = TestHeader.InitFromFile(Reader); // test UL and OP
+
+      if ( ASDCP_SUCCESS(result) )
+	{
+	  TestHeader.Partition::Dump(stdout);
+
+	  if ( MXF::Identification* ID = TestHeader.GetIdentification() )
+	    ID->Dump(stdout);
+	  else
+	    fputs("File contains no Identification object.\n", stdout);
+
+	  if ( MXF::SourcePackage* SP = TestHeader.GetSourcePackage() )
+	    SP->Dump(stdout);
+	  else
+	    fputs("File contains no SourcePackage object.\n", stdout);
+	}
+      else
+	{
+	  fputs("File is not MXF.\n", stdout);
+	}
+    }
+
+  return result;
+}
+
+
+//
+Result_t
+digest_file(const char* filename)
+{
+  using namespace Kumu;
+
+  ASDCP_TEST_NULL_STR(filename);
+  FileReader Reader;
+  SHA_CTX Ctx;
+  SHA1_Init(&Ctx);
+  ByteString Buf(8192);
+
+  Result_t result = Reader.OpenRead(filename);
+
+  while ( ASDCP_SUCCESS(result) )
+    {
+      ui32_t read_count = 0;
+      result = Reader.Read(Buf.Data(), Buf.Capacity(), &read_count);
+
+      if ( result == RESULT_ENDOFFILE )
+	{
+	  result = RESULT_OK;
+	  break;
+	}
+
+      if ( ASDCP_SUCCESS(result) )
+	SHA1_Update(&Ctx, Buf.Data(), read_count);
+    }
+
+  if ( ASDCP_SUCCESS(result) )
+    {
+      const ui32_t sha_len = 20;
+      byte_t bin_buf[sha_len];
+      char sha_buf[64];
+      SHA1_Final(bin_buf, &Ctx);
+
+      fprintf(stdout, "%s %s\n", base64encode(bin_buf, sha_len, sha_buf, 64), filename);
+    }
+
+  return result;
+}
+
+//
+int
+main(int argc, const char** argv)
+{
+  Result_t result = RESULT_OK;
+  char     str_buf[64];
+  CommandOptions Options(argc, argv);
+
+  if ( Options.version_flag )
+    banner();
+
+  if ( Options.help_flag )
+    usage();
+
+  if ( Options.version_flag || Options.help_flag )
+    return 0;
+
+  if ( Options.error_flag )
+    {
+      fprintf(stderr, "There was a problem. Type %s -h for help.\n", PROGRAM_NAME);
+      return 3;
+    }
+
+  if ( Options.mode == MMT_INFO )
+    {
+      result = show_file_info(Options);
+
+      for ( int i = 1; ASDCP_SUCCESS(result) && i < Options.file_count; ++i )
+	{
+	  Options.filenames[0] = Options.filenames[i]; // oh-so hackish
+	  result = show_file_info(Options);
+	}
+    }
+  else if ( Options.mode == MMT_GOP_START )
+    {
+      result = gop_start_test(Options);
+    }
+  else if ( Options.mode == MMT_GEN_KEY )
+    {
+      Kumu::FortunaRNG RNG;
+      byte_t bin_buf[KeyLen];
+
+      RNG.FillRandom(bin_buf, KeyLen);
+      printf("%s\n", Kumu::bin2hex(bin_buf, KeyLen, str_buf, 64));
+    }
+  else if ( Options.mode == MMT_GEN_ID )
+    {
+      UUID TmpID;
+      Kumu::GenRandomValue(TmpID);
+      printf("%s\n", TmpID.EncodeHex(str_buf, 64));
+    }
+  else if ( Options.mode == MMT_DIGEST )
+    {
+      for ( ui32_t i = 0; i < Options.file_count && ASDCP_SUCCESS(result); i++ )
+	result = digest_file(Options.filenames[i]);
+    }
+  else if ( Options.mode == MMT_UL_LIST )
+    {
+      if ( Options.use_smpte_labels )
+	DefaultSMPTEDict().Dump(stdout);
+      else
+	DefaultInteropDict().Dump(stdout);
+    }
+  else if ( Options.mode == MMT_EXTRACT )
+    {
+      EssenceType_t EssenceType;
+      result = ASDCP::EssenceType(Options.filenames[0], EssenceType);
+
+      if ( ASDCP_SUCCESS(result) )
+	{
+	  switch ( EssenceType )
+	    {
+	    case ESS_MPEG2_VES:
+	      result = read_MPEG2_file(Options);
+	      break;
+
+	    case ESS_JPEG_2000:
+	      if ( Options.stereo_image_flag )
+		result = read_JP2K_S_file(Options);
+	      else
+		result = read_JP2K_file(Options);
+	      break;
+
+	    case ESS_JPEG_2000_S:
+	      result = read_JP2K_S_file(Options);
+	      break;
+
+	    case ESS_PCM_24b_48k:
+	    case ESS_PCM_24b_96k:
+	      result = read_PCM_file(Options);
+	      break;
+
+	    case ESS_TIMED_TEXT:
+	      result = read_timed_text_file(Options);
+	      break;
+
+	    default:
+	      fprintf(stderr, "%s: Unknown file type, not ASDCP essence.\n", Options.filenames[0]);
+	      return 5;
+	    }
+	}
+    }
+  else if ( Options.mode == MMT_CREATE )
+    {
+      if ( Options.do_repeat && ! Options.duration_flag )
+	{
+	  fputs("Option -R requires -d <duration>\n", stderr);
+	  return RESULT_FAIL;
+	}
+
+      EssenceType_t EssenceType;
+      result = ASDCP::RawEssenceType(Options.filenames[0], EssenceType);
+
+      if ( ASDCP_SUCCESS(result) )
+	{
+	  switch ( EssenceType )
+	    {
+	    case ESS_MPEG2_VES:
+	      result = write_MPEG2_file(Options);
+	      break;
+
+	    case ESS_JPEG_2000:
+	      if ( Options.stereo_image_flag )
+		result = write_JP2K_S_file(Options);
+
+	      else
+		result = write_JP2K_file(Options);
+
+	      break;
+
+	    case ESS_PCM_24b_48k:
+	    case ESS_PCM_24b_96k:
+	      result = write_PCM_file(Options);
+	      break;
+
+	    case ESS_TIMED_TEXT:
+	      result = write_timed_text_file(Options);
+	      break;
+
+	    default:
+	      fprintf(stderr, "%s: Unknown file type, not ASDCP-compatible essence.\n",
+		      Options.filenames[0]);
+	      return 5;
+	    }
+	}
+    }
+  else
+    {
+      fprintf(stderr, "Unhandled mode: %d.\n", Options.mode);
+      return 6;
+    }
+
+  if ( ASDCP_FAILURE(result) )
+    {
+      fputs("Program stopped on error.\n", stderr);
+
+      if ( result == RESULT_SFORMAT )
+	{
+	  fputs("Use option '-3' to force stereoscopic mode.\n", stderr);
+	}
+      else if ( result != RESULT_FAIL )
+	{
+	  fputs(result, stderr);
+	  fputc('\n', stderr);
+	}
+
+      return 1;
+    }
+
+  return 0;
+}
+
+
+//
+// end asdcp-test.cpp
+//
diff -ruN asdcplib.old/src/asdcp-util.cpp asdcplib/src/asdcp-util.cpp
--- asdcplib.old/src/asdcp-util.cpp	2017-01-17 22:38:59.494475028 +0100
+++ asdcplib/src/asdcp-util.cpp	2017-01-17 22:40:55.166469875 +0100
@@ -36,7 +36,7 @@
 #include <KM_fileio.h>
 #include <KM_prng.h>
 #include <AS_DCP.h>
-#include <openssl/sha.h>
+#include <nettle/sha.h>
 
 using namespace Kumu;
 
@@ -182,8 +182,8 @@
 digest_file(const std::string& filename)
 {
   FileReader Reader;
-  SHA_CTX Ctx;
-  SHA1_Init(&Ctx);
+  sha1_ctx Ctx;
+  sha1_init(&Ctx);
   ByteString Buf(8192);
 
   Result_t result = Reader.OpenRead(filename.c_str());
@@ -200,7 +200,7 @@
 	}
 
       if ( ASDCP_SUCCESS(result) )
-	SHA1_Update(&Ctx, Buf.Data(), read_count);
+	sha1_update(&Ctx, read_count, Buf.Data());
     }
 
   if ( ASDCP_SUCCESS(result) )
@@ -208,7 +208,7 @@
       const ui32_t sha_len = 20;
       byte_t bin_buf[sha_len];
       char sha_buf[64];
-      SHA1_Final(bin_buf, &Ctx);
+      sha1_digest(&Ctx, sizeof(bin_buf), bin_buf );
 
       fprintf(stdout, "%s %s\n",
 	      base64encode(bin_buf, sha_len, sha_buf, 64),
diff -ruN asdcplib.old/src/fips-186-rng-test.cpp asdcplib/src/fips-186-rng-test.cpp
--- asdcplib.old/src/fips-186-rng-test.cpp	2017-01-17 22:38:59.494475028 +0100
+++ asdcplib/src/fips-186-rng-test.cpp	2017-01-17 22:40:55.166469875 +0100
@@ -31,7 +31,7 @@
 
 #include <KM_util.h>
 #include <KM_prng.h>
-#include <openssl/sha.h>
+#include <nettle/sha.h>
 
 using namespace Kumu;
 
diff -ruN asdcplib.old/src/kmfilegen.cpp asdcplib/src/kmfilegen.cpp
--- asdcplib.old/src/kmfilegen.cpp	2017-01-17 22:38:59.494475028 +0100
+++ asdcplib/src/kmfilegen.cpp	2017-01-17 22:40:55.166469875 +0100
@@ -34,7 +34,7 @@
 #include <iostream>
 #include <KM_fileio.h>
 #include <KM_prng.h>
-#include <openssl/aes.h>
+#include <nettle/aes.h>
 #include <assert.h>
 
 using namespace Kumu;
@@ -239,7 +239,7 @@
 #pragma pack(4)
 class CTR_Setup
 {
-  AES_KEY  m_Context;
+  aes128_ctx  m_Context;
   byte_t   m_key[RNG_KEY_SIZE];
   byte_t   m_preamble[8];
   ui32_t   m_nonce;
@@ -264,7 +264,7 @@
     m_nonce = KM_i32_LE(s_Nonce--);
     m_ctr &= KM_i32_LE(0x7fffffff); // make sure we have 2GB headroom
     memcpy(buf, m_key, WriteSize());
-    AES_set_encrypt_key(m_key, RNG_KEY_SIZE_BITS, &m_Context);
+    aes128_set_encrypt_key(&m_Context, m_key );
   }
 
   //
@@ -272,7 +272,7 @@
   {
     assert(buf);
     memcpy(m_key, buf, WriteSize());
-    AES_set_encrypt_key(m_key, RNG_KEY_SIZE_BITS, &m_Context);
+    aes128_set_encrypt_key(&m_Context, m_key );
   }
 
   //
@@ -281,7 +281,7 @@
     ui32_t gen_count = 0;
     while ( gen_count + RNG_BLOCK_SIZE <= buf_len )
       {
-	AES_encrypt(m_preamble, buf + gen_count, &m_Context);
+	aes128_encrypt(&m_Context, sizeof(m_preamble), buf + gen_count, m_preamble);
 	m_ctr = KM_i32_LE(KM_i32_LE(m_ctr) + 1);
 	gen_count += RNG_BLOCK_SIZE;
       }
diff -ruN asdcplib.old/src/KM_prng.cpp asdcplib/src/KM_prng.cpp
--- asdcplib.old/src/KM_prng.cpp	2017-01-17 22:38:59.494475028 +0100
+++ asdcplib/src/KM_prng.cpp	2017-01-17 22:40:55.166469875 +0100
@@ -30,13 +30,19 @@
   */
 
 #include <KM_prng.h>
+  /*! \file    KM_prng.cpp
+    \version $Id: KM_prng.cpp,v 1.9 2011/06/14 23:38:33 jhurst Exp $
+    \brief   Fortuna pseudo-random number generator
+  */
+
+#include <KM_prng.h>
 #include <KM_log.h>
 #include <KM_mutex.h>
 #include <string.h>
 #include <assert.h>
-#include <openssl/aes.h>
-#include <openssl/sha.h>
-#include <openssl/bn.h>
+#include <nettle/sha1.h>
+#include <nettle/aes.h>
+#include <nettle/bignum.h>
 
 using namespace Kumu;
 
@@ -61,7 +67,7 @@
   KM_NO_COPY_CONSTRUCT(h__RNG);
 
 public:
-  AES_KEY   m_Context;
+  struct aes128_ctx   m_Context;
   byte_t    m_ctr_buf[RNG_BLOCK_SIZE];
   Mutex     m_Lock;
 
@@ -104,16 +110,16 @@
   set_key(const byte_t* key_fodder)
   {
     assert(key_fodder);
-    byte_t sha_buf[20];
-    SHA_CTX SHA;
-    SHA1_Init(&SHA);
-
-    SHA1_Update(&SHA, (byte_t*)&m_Context, sizeof(m_Context));
-    SHA1_Update(&SHA, key_fodder, RNG_KEY_SIZE);
-    SHA1_Final(sha_buf, &SHA);
+    byte_t sha_buf[SHA1_DIGEST_SIZE];
+    struct sha1_ctx SHA;
+    sha1_init(&SHA);
+
+    sha1_update(&SHA, sizeof(m_Context), (byte_t*)&m_Context );
+    sha1_update(&SHA, sizeof(key_fodder), key_fodder);
+    sha1_digest(&SHA, sizeof(sha_buf), sha_buf);
 
     AutoMutex Lock(m_Lock);
-    AES_set_encrypt_key(sha_buf, RNG_KEY_SIZE_BITS, &m_Context);
+    aes128_set_encrypt_key(&m_Context, sha_buf);
     *(ui32_t*)(m_ctr_buf + 12) = 1;
   }
 	
@@ -127,7 +133,7 @@
 
     while ( gen_count + RNG_BLOCK_SIZE <= len )
       {
-	AES_encrypt(m_ctr_buf, buf + gen_count, &m_Context);
+	aes128_encrypt(&m_Context,sizeof(m_ctr_buf), buf + gen_count,  m_ctr_buf);
 	*(ui32_t*)(m_ctr_buf + 12) += 1;
 	gen_count += RNG_BLOCK_SIZE;
       }
@@ -135,7 +141,7 @@
     if ( len != gen_count ) // partial count needed?
       {
 	byte_t tmp[RNG_BLOCK_SIZE];
-	AES_encrypt(m_ctr_buf, tmp, &m_Context);
+	aes128_encrypt(&m_Context,sizeof(m_ctr_buf),  tmp, m_ctr_buf );
 	memcpy(buf + gen_count, tmp, len - gen_count);
       }
   }
@@ -199,11 +205,10 @@
 void
 Kumu::Gen_FIPS_186_Value(const byte_t* key, ui32_t key_size, byte_t* out_buf, ui32_t out_buf_len)
 {
-  byte_t sha_buf[SHA_DIGEST_LENGTH];
+  byte_t sha_buf[SHA1_DIGEST_SIZE];
   ui32_t const xkey_len = 64; // 512/8
   byte_t xkey[xkey_len];
-  BN_CTX* ctx1 = BN_CTX_new(); // used by BN_* functions
-  assert(ctx1);
+
 
   if ( key_size > xkey_len )
     DefaultLogSink().Warn("Key too large for FIPS 186 seed, truncating to 64 bytes.\n");
@@ -212,55 +217,57 @@
   memset(xkey, 0, xkey_len);
   memcpy(xkey, key, xmin<ui32_t>(key_size, xkey_len));
 
-  if ( key_size < SHA_DIGEST_LENGTH )
-    key_size = SHA_DIGEST_LENGTH; // pad short key ( b < 160 )
+  if ( key_size < SHA1_DIGEST_SIZE )
+    key_size = SHA1_DIGEST_SIZE; // pad short key ( b < 160 )
 
   // create the 2^b constant
-  BIGNUM c_2powb, c_2, c_b;
-  BN_init(&c_2powb);  BN_init(&c_2);  BN_init(&c_b);
-  BN_set_word(&c_2, 2);
-  BN_set_word(&c_b, key_size * 8);
-  BN_exp(&c_2powb, &c_2, &c_b, ctx1);
+  mpz_t c_2powb, c_2, c_b, c_mod;
+  mpz_init(c_2powb);
+  mpz_init_set_si(c_2, 2);
+  mpz_init_set_si(c_b, key_size * 8);
+  mpz_init_set_si(c_mod, 1);
+  mpz_powm(c_2powb, c_2, c_b, c_mod);
 
   for (;;)
     {
-      SHA_CTX SHA;
+     struct sha1_ctx SHA;
 
       // step c -- x = G(t,xkey)
-      SHA1_Init(&SHA); // set t
-      SHA1_Update(&SHA, xkey, xkey_len);
+      sha1_init(&SHA); // set t
+      sha1_update(&SHA, xkey_len, xkey);
 
       ui32_t* buf_p = (ui32_t*)sha_buf;
-      *buf_p++ = KM_i32_BE(SHA.h0);
-      *buf_p++ = KM_i32_BE(SHA.h1);
-      *buf_p++ = KM_i32_BE(SHA.h2);
-      *buf_p++ = KM_i32_BE(SHA.h3);
-      *buf_p++ = KM_i32_BE(SHA.h4);
-      memcpy(out_buf, sha_buf, xmin<ui32_t>(out_buf_len, SHA_DIGEST_LENGTH));
+      *buf_p++ = KM_i32_BE(SHA.state[0]);
+      *buf_p++ = KM_i32_BE(SHA.state[1]);
+      *buf_p++ = KM_i32_BE(SHA.state[2]);
+      *buf_p++ = KM_i32_BE(SHA.state[3]);
+      *buf_p++ = KM_i32_BE(SHA.state[4]);
+      memcpy(out_buf, sha_buf, xmin<ui32_t>(out_buf_len, SHA1_DIGEST_SIZE));
 
-      if ( out_buf_len <= SHA_DIGEST_LENGTH )
+      if ( out_buf_len <= SHA1_DIGEST_SIZE )
 	break;
 
-      out_buf_len -= SHA_DIGEST_LENGTH;
-      out_buf += SHA_DIGEST_LENGTH;
+      out_buf_len -= SHA1_DIGEST_SIZE;
+      out_buf += SHA1_DIGEST_SIZE;
 
       // step d -- XKEY = (1 + XKEY + x) mod 2^b
-      BIGNUM bn_tmp, bn_xkey, bn_x_n;
-      BN_init(&bn_tmp);  BN_init(&bn_xkey);    BN_init(&bn_x_n);
-
-      BN_bin2bn(xkey, key_size, &bn_xkey);
-      BN_bin2bn(sha_buf, SHA_DIGEST_LENGTH, &bn_x_n);
-      BN_add_word(&bn_xkey, 1);            // xkey += 1
-      BN_add(&bn_tmp, &bn_xkey, &bn_x_n);       // xkey += x
-      BN_mod(&bn_xkey, &bn_tmp, &c_2powb, ctx1);  // xkey = xkey mod (2^b)
+      mpz_t bn_tmp, bn_xkey, bn_x_n;
+      mpz_init(bn_tmp);
+      mpz_init(bn_xkey);
+      mpz_init(bn_x_n);
+
+      mpz_import (bn_xkey, key_size, 1, 1, 0, 0, xkey);
+      mpz_import (bn_x_n, SHA1_DIGEST_SIZE, 1, 1, 0, 0, sha_buf);
+      mpz_add_ui(bn_xkey,bn_xkey, 1);            // xkey += 1
+      mpz_add(bn_xkey, bn_xkey, bn_x_n);       // xkey += x
+      mpz_mod(bn_xkey, bn_xkey, c_2powb);  // xkey = xkey mod (2^b)
 
       memset(xkey, 0, xkey_len);
-      ui32_t bn_buf_len = BN_num_bytes(&bn_xkey);
+      ui32_t bn_buf_len = bn_xkey->_mp_size;
       ui32_t idx = ( bn_buf_len < key_size ) ? key_size - bn_buf_len : 0;
-      BN_bn2bin(&bn_xkey, &xkey[idx]);
-    }
+      mpz_export (xkey+idx, NULL, 1, 1, 0, 0, bn_xkey);
 
-  BN_CTX_free(ctx1);
+    }
 }
 
 //
diff -ruN asdcplib.old/src/ST2052_TextParser.cpp asdcplib/src/ST2052_TextParser.cpp
--- asdcplib.old/src/ST2052_TextParser.cpp	2017-01-17 22:38:59.494475028 +0100
+++ asdcplib/src/ST2052_TextParser.cpp	2017-01-17 22:40:55.166469875 +0100
@@ -31,7 +31,7 @@
 
 #include "AS_02_internal.h"
 #include "KM_xml.h"
-#include <openssl/sha.h>
+#include <nettle/sha.h>
 
 using namespace Kumu;
 using namespace ASDCP;
