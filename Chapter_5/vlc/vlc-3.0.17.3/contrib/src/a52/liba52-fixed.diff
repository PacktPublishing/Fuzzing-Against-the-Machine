diff -ruN a52dec.orig/include/a52.h a52dec/include/a52.h
--- a52dec.orig/include/a52.h	2012-11-13 17:25:33.438758556 +0100
+++ a52dec/include/a52.h	2012-11-13 17:27:31.143704187 +0100
@@ -1,6 +1,6 @@
 /*
  * a52.h
- * Copyright (C) 2000-2002 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
  * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
  *
  * This file is part of a52dec, a free ATSC A-52 stream decoder.
@@ -24,10 +24,17 @@
 #ifndef A52_H
 #define A52_H
 
-#ifndef LIBA52_DOUBLE
-typedef float sample_t;
-#else
+#define LIBA52_FIXED
+
+#if defined(LIBA52_FIXED)
+typedef int32_t sample_t;
+typedef int32_t level_t;
+#elif defined(LIBA52_DOUBLE)
 typedef double sample_t;
+typedef double level_t;
+#else
+typedef float sample_t;
+typedef float level_t;
 #endif
 
 typedef struct a52_state_s a52_state_t;
@@ -53,9 +60,9 @@
 int a52_syncinfo (uint8_t * buf, int * flags,
 		  int * sample_rate, int * bit_rate);
 int a52_frame (a52_state_t * state, uint8_t * buf, int * flags,
-	       sample_t * level, sample_t bias);
+	       level_t * level, sample_t bias);
 void a52_dynrng (a52_state_t * state,
-		 sample_t (* call) (sample_t, void *), void * data);
+		 level_t (* call) (level_t, void *), void * data);
 int a52_block (a52_state_t * state);
 void a52_free (a52_state_t * state);
 
diff -ruN a52dec.orig/include/attributes.h a52dec/include/attributes.h
--- a52dec.orig/include/attributes.h	2012-11-13 17:25:33.438758556 +0100
+++ a52dec/include/attributes.h	2012-11-13 17:27:31.147037566 +0100
@@ -1,6 +1,6 @@
 /*
  * attributes.h
- * Copyright (C) 2000-2002 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
  * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
  *
  * This file is part of a52dec, a free ATSC A-52 stream decoder.
@@ -27,3 +27,11 @@
 #else
 #define ATTR_ALIGN(align)
 #endif
+
+#ifdef HAVE_BUILTIN_EXPECT
+#define likely(x) __builtin_expect ((x) != 0, 1)
+#define unlikely(x) __builtin_expect ((x) != 0, 0)
+#else
+#define likely(x) (x)
+#define unlikely(x) (x)
+#endif
diff -ruN a52dec.orig/include/mm_accel.h a52dec/include/mm_accel.h
--- a52dec.orig/include/mm_accel.h	2012-11-13 17:25:33.438758556 +0100
+++ a52dec/include/mm_accel.h	2012-11-13 17:27:31.147037566 +0100
@@ -1,6 +1,6 @@
 /*
  * mm_accel.h
- * Copyright (C) 2000-2002 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
  * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
  *
  * This file is part of a52dec, a free ATSC A-52 stream decoder.
diff -ruN a52dec.orig/include/tendra.h a52dec/include/tendra.h
--- a52dec.orig/include/tendra.h	2012-11-13 17:25:33.438758556 +0100
+++ a52dec/include/tendra.h	2012-11-13 17:27:31.147037566 +0100
@@ -1,6 +1,6 @@
 /*
  * tendra.h
- * Copyright (C) 2000-2002 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
  * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
  *
  * This file is part of a52dec, a free ATSC A-52 stream decoder.
diff -ruN a52dec.orig/liba52/a52_internal.h a52dec/liba52/a52_internal.h
--- a52dec.orig/liba52/a52_internal.h	2012-11-13 17:25:33.438758556 +0100
+++ a52dec/liba52/a52_internal.h	2012-11-13 17:27:31.147037566 +0100
@@ -1,6 +1,6 @@
 /*
  * a52_internal.h
- * Copyright (C) 2000-2002 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
  * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
  *
  * This file is part of a52dec, a free ATSC A-52 stream decoder.
@@ -37,24 +37,24 @@
     uint8_t halfrate;		/* halfrate factor */
     uint8_t acmod;		/* coded channels */
     uint8_t lfeon;		/* coded lfe channel */
-    sample_t clev;		/* centre channel mix level */
-    sample_t slev;		/* surround channels mix level */
+    level_t clev;		/* centre channel mix level */
+    level_t slev;		/* surround channels mix level */
 
     int output;			/* type of output */
-    sample_t level;		/* output level */
+    level_t level;		/* output level */
     sample_t bias;		/* output bias */
 
     int dynrnge;		/* apply dynamic range */
-    sample_t dynrng;		/* dynamic range */
+    level_t dynrng;		/* dynamic range */
     void * dynrngdata;		/* dynamic range callback funtion and data */
-    sample_t (* dynrngcall) (sample_t range, void * dynrngdata);
+    level_t (* dynrngcall) (level_t range, void * dynrngdata);
 
     uint8_t chincpl;		/* channel coupled */
     uint8_t phsflginu;		/* phase flags in use (stereo only) */
     uint8_t cplstrtmant;	/* coupling channel start mantissa */
     uint8_t cplendmant;		/* coupling channel end mantissa */
     uint32_t cplbndstrc;	/* coupling band structure */
-    sample_t cplco[5][18];	/* coupling coordinates */
+    level_t cplco[5][18];	/* coupling coordinates */
 
     /* derived information */
     uint8_t cplstrtbnd;		/* coupling start band (for bit allocation) */
@@ -107,14 +107,79 @@
 		       int start, int end, int fastleak, int slowleak,
 		       expbap_t * expbap);
 
-int a52_downmix_init (int input, int flags, sample_t * level,
-		      sample_t clev, sample_t slev);
-int a52_downmix_coeff (sample_t * coeff, int acmod, int output, sample_t level,
-		       sample_t clev, sample_t slev);
+int a52_downmix_init (int input, int flags, level_t * level,
+		      level_t clev, level_t slev);
+int a52_downmix_coeff (level_t * coeff, int acmod, int output, level_t level,
+		       level_t clev, level_t slev);
 void a52_downmix (sample_t * samples, int acmod, int output, sample_t bias,
-		  sample_t clev, sample_t slev);
+		  level_t clev, level_t slev);
 void a52_upmix (sample_t * samples, int acmod, int output);
 
 void a52_imdct_init (uint32_t mm_accel);
 void a52_imdct_256 (sample_t * data, sample_t * delay, sample_t bias);
 void a52_imdct_512 (sample_t * data, sample_t * delay, sample_t bias);
+
+#define ROUND(x) ((int)((x) + ((x) > 0 ? 0.5 : -0.5)))
+
+#ifndef LIBA52_FIXED
+
+typedef sample_t quantizer_t;
+#define SAMPLE(x) (x)
+#define LEVEL(x) (x)
+#define MUL(a,b) ((a) * (b))
+#define MUL_L(a,b) ((a) * (b))
+#define MUL_C(a,b) ((a) * (b))
+#define DIV(a,b) ((a) / (b))
+#define BIAS(x) ((x) + bias)
+
+#else /* LIBA52_FIXED */
+
+typedef int16_t quantizer_t;
+#define SAMPLE(x) (sample_t)((x) * (1 << 30))
+#define LEVEL(x) (level_t)((x) * (1 << 26))
+
+#if 0
+#define MUL(a,b) ((int)(((int64_t)(a) * (b) + (1 << 29)) >> 30))
+#define MUL_L(a,b) ((int)(((int64_t)(a) * (b) + (1 << 25)) >> 26))
+#elif defined(CPU_COLDFIRE)
+/* loses 1 bit of accuracy */
+#define MUL(a, b) \
+({ \
+    int32_t t; \
+    asm volatile ( \
+        "mac.l %[A], %[B], %%acc0\n\t" \
+        "movclr.l %%acc0, %[t]\n\t" \
+        "asl.l #1, %[t]" \
+        : [t] "=d" (t) \
+        : [A] "r" ((a)), [B] "r" ((b))); \
+    t; \
+})
+/* loses 5 bits of accuracy */
+#define MUL_L(a, b) \
+({ \
+    int32_t t; \
+    asm volatile ( \
+        "mac.l %[A], %[B], %%acc0\n\t" \
+        "movclr.l %%acc0, %[t]\n\t" \
+        "asl.l #5, %[t]" \
+        : [t] "=d" (t) \
+        : [A] "r" ((a)), [B] "r" ((b))); \
+    t; \
+})
+#elif 1
+#define MUL(a,b) \
+({ int32_t _ta=(a), _tb=(b), _tc; \
+   _tc=(_ta & 0xffff)*(_tb >> 16)+(_ta >> 16)*(_tb & 0xffff); (int32_t)(((_tc >> 14))+ (((_ta >> 16)*(_tb >> 16)) << 2 )); })
+#define MUL_L(a,b) \
+({ int32_t _ta=(a), _tb=(b), _tc; \
+   _tc=(_ta & 0xffff)*(_tb >> 16)+(_ta >> 16)*(_tb & 0xffff); (int32_t)((_tc >> 10) + (((_ta >> 16)*(_tb >> 16)) << 6)); })
+#else
+#define MUL(a,b) (((a) >> 15) * ((b) >> 15))
+#define MUL_L(a,b) (((a) >> 13) * ((b) >> 13))
+#endif
+
+#define MUL_C(a,b) MUL_L (a, LEVEL (b))
+#define DIV(a,b) ((((int64_t)LEVEL (a)) << 26) / (b))
+#define BIAS(x) ((x) + (bias*0))
+
+#endif
diff -ruN a52dec.orig/liba52/bit_allocate.c a52dec/liba52/bit_allocate.c
--- a52dec.orig/liba52/bit_allocate.c	2012-11-13 17:25:33.438758556 +0100
+++ a52dec/liba52/bit_allocate.c	2012-11-13 17:27:31.147037566 +0100
@@ -1,6 +1,6 @@
 /*
  * bit_allocate.c
- * Copyright (C) 2000-2002 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
  * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
  *
  * This file is part of a52dec, a free ATSC A-52 stream decoder.
@@ -21,14 +21,14 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "config.h"
+#include "config-a52.h"
 
 #include <inttypes.h>
 
 #include "a52.h"
 #include "a52_internal.h"
 
-static int hthtab[3][50] = {
+static int hthtab[3][50] IDATA_ATTR = {
     {0x730, 0x730, 0x7c0, 0x800, 0x820, 0x840, 0x850, 0x850, 0x860, 0x860,
      0x860, 0x860, 0x860, 0x870, 0x870, 0x870, 0x880, 0x880, 0x890, 0x890,
      0x8a0, 0x8a0, 0x8b0, 0x8b0, 0x8c0, 0x8c0, 0x8d0, 0x8e0, 0x8f0, 0x900,
@@ -46,7 +46,7 @@
      0x8d0, 0x8b0, 0x840, 0x7f0, 0x790, 0x760, 0x7a0, 0x7c0, 0x7b0, 0x720}
 };
 
-static int8_t baptab[305] = {
+static int8_t baptab[305] IDATA_ATTR = {
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
@@ -71,11 +71,11 @@
      0,  0,  0,  0					/* 148 padding elems */
 };
 
-static int bndtab[30] = {21, 22,  23,  24,  25,  26,  27,  28,  31,  34,
+static int bndtab[30] IDATA_ATTR = {21, 22,  23,  24,  25,  26,  27,  28,  31,  34,
 			 37, 40,  43,  46,  49,  55,  61,  67,  73,  79,
 			 85, 97, 109, 121, 133, 157, 181, 205, 229, 253};
 
-static int8_t latab[256] = {
+static int8_t latab[256] IDATA_ATTR = {
     -64, -63, -62, -61, -60, -59, -58, -57, -56, -55, -54, -53,
     -52, -52, -51, -50, -49, -48, -47, -47, -46, -45, -44, -44,
     -43, -42, -41, -41, -40, -39, -38, -38, -37, -36, -36, -35,
@@ -231,7 +231,7 @@
 	int startband, endband;
 
 	startband = j;
-	endband = ((bndtab-20)[i] < end) ? (bndtab-20)[i] : end;
+	endband = (bndtab[i-20] < end) ? bndtab[i-20] : end;
 	psd = 128 * exp[j++];
 	while (j < endband) {
 	    int next, delta;
diff -ruN a52dec.orig/liba52/bitstream.c a52dec/liba52/bitstream.c
--- a52dec.orig/liba52/bitstream.c	2012-11-13 17:25:33.442091935 +0100
+++ a52dec/liba52/bitstream.c	2012-11-13 17:27:31.147037566 +0100
@@ -1,6 +1,6 @@
 /*
  * bitstream.c
- * Copyright (C) 2000-2002 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
  * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
  *
  * This file is part of a52dec, a free ATSC A-52 stream decoder.
@@ -21,7 +21,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "config.h"
+#include "config-a52.h"
 
 #include <inttypes.h>
 
@@ -38,7 +38,9 @@
     align = (long)buf & 3;
     state->buffer_start = (uint32_t *) (buf - align);
     state->bits_left = 0;
+    state->current_word = 0;
     bitstream_get (state, align * 8);
+    bitstream_get_2 (state, 0);	/* pretend function is used - keep gcc happy */
 }
 
 static inline void bitstream_fill_current (a52_state_t * state)
diff -ruN a52dec.orig/liba52/bitstream.h a52dec/liba52/bitstream.h
--- a52dec.orig/liba52/bitstream.h	2012-11-13 17:25:33.442091935 +0100
+++ a52dec/liba52/bitstream.h	2012-11-13 17:27:31.147037566 +0100
@@ -1,6 +1,6 @@
 /*
  * bitstream.h
- * Copyright (C) 2000-2002 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
  * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
  *
  * This file is part of a52dec, a free ATSC A-52 stream decoder.
@@ -21,29 +21,29 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-/* (stolen from the kernel) */
+//#define swab32(x) (betoh32(x))
 #ifdef WORDS_BIGENDIAN
 
-#	define swab32(x) (x)
+#   define swab32(x) (x)
 
 #else
 
-#	if 0 && defined (__i386__)
+#   if defined (__i386__)
 
-#	define swab32(x) __i386_swab32(x)
-	static inline const uint32_t __i386_swab32(uint32_t x)
-	{
-		__asm__("bswap %0" : "=r" (x) : "0" (x));
-		return x;
-	}
+#   define swab32(x) __i386_swab32(x)
+    static inline const uint32_t __i386_swab32(uint32_t x)
+    {
+        __asm__("bswap %0" : "=r" (x) : "0" (x));
+        return x;
+    }
 
-#	else
+#   else
 
-#	define swab32(x)\
+#   define swab32(x)\
 ((((uint8_t*)&x)[0] << 24) | (((uint8_t*)&x)[1] << 16) |  \
  (((uint8_t*)&x)[2] << 8)  | (((uint8_t*)&x)[3]))
 
-#	endif
+#   endif
 #endif
 
 void a52_bitstream_set_ptr (a52_state_t * state, uint8_t * buf);
diff -ruN a52dec.orig/liba52/config-a52.h a52dec/liba52/config-a52.h
--- a52dec.orig/liba52/config-a52.h	1970-01-01 01:00:00.000000000 +0100
+++ a52dec/liba52/config-a52.h	2012-11-13 17:27:31.150370945 +0100
@@ -0,0 +1,26 @@
+#define IDATA_ATTR
+#define IBSS_ATTR
+/* a52dec profiling */
+/* #undef A52DEC_GPROF */
+
+/* Define to 1 if you have the `memalign' function. */
+/* #undef HAVE_MEMALIGN 1 */
+
+/* liba52 djbfft support */
+/* #undef LIBA52_DJBFFT */
+
+/* a52 sample precision */
+/* #undef LIBA52_DOUBLE */
+
+/* use fixed-point arithmetic */
+#define LIBA52_FIXED
+
+/* Define to 1 if your processor stores words with the most significant byte
+   first (like Motorola and SPARC, unlike Intel and VAX). */
+
+/* Used in bitstream.h */
+
+#ifdef ROCKBOX_BIG_ENDIAN
+#define WORDS_BIGENDIAN 1
+#endif
+
diff -ruN a52dec.orig/liba52/downmix.c a52dec/liba52/downmix.c
--- a52dec.orig/liba52/downmix.c	2012-11-13 17:25:33.442091935 +0100
+++ a52dec/liba52/downmix.c	2012-11-13 17:27:31.150370945 +0100
@@ -1,6 +1,6 @@
 /*
  * downmix.c
- * Copyright (C) 2000-2002 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
  * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
  *
  * This file is part of a52dec, a free ATSC A-52 stream decoder.
@@ -21,7 +21,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "config.h"
+#include "config-a52.h"
 
 #include <string.h>
 #include <inttypes.h>
@@ -31,8 +31,8 @@
 
 #define CONVERT(acmod,output) (((output) << 3) + (acmod))
 
-int a52_downmix_init (int input, int flags, sample_t * level,
-		      sample_t clev, sample_t slev)
+int a52_downmix_init (int input, int flags, level_t * level,
+		      level_t clev, level_t slev)
 {
     static uint8_t table[11][8] = {
 	{A52_CHANNEL,	A52_DOLBY,	A52_STEREO,	A52_STEREO,
@@ -66,94 +66,106 @@
 
     output = table[output][input & 7];
 
-    if ((output == A52_STEREO) &&
-	((input == A52_DOLBY) || ((input == A52_3F) && (clev == LEVEL_3DB))))
+    if (output == A52_STEREO &&
+	(input == A52_DOLBY || (input == A52_3F && clev == LEVEL (LEVEL_3DB))))
 	output = A52_DOLBY;
 
-    if (flags & A52_ADJUST_LEVEL)
+    if (flags & A52_ADJUST_LEVEL) {
+	level_t adjust;
+
 	switch (CONVERT (input & 7, output)) {
 
 	case CONVERT (A52_3F, A52_MONO):
-	    *level *= LEVEL_3DB / (1 + clev);
+	    adjust = DIV (LEVEL_3DB, LEVEL (1) + clev);
 	    break;
 
 	case CONVERT (A52_STEREO, A52_MONO):
 	case CONVERT (A52_2F2R, A52_2F1R):
 	case CONVERT (A52_3F2R, A52_3F1R):
 	level_3db:
-	    *level *= LEVEL_3DB;
+	    adjust = LEVEL (LEVEL_3DB);
 	    break;
 
 	case CONVERT (A52_3F2R, A52_2F1R):
-	    if (clev < LEVEL_PLUS3DB - 1)
+	    if (clev < LEVEL (LEVEL_PLUS3DB - 1))
 		goto level_3db;
 	    /* break thru */
 	case CONVERT (A52_3F, A52_STEREO):
 	case CONVERT (A52_3F1R, A52_2F1R):
 	case CONVERT (A52_3F1R, A52_2F2R):
 	case CONVERT (A52_3F2R, A52_2F2R):
-	    *level /= 1 + clev;
+	    adjust = DIV (1, LEVEL (1) + clev);
 	    break;
 
 	case CONVERT (A52_2F1R, A52_MONO):
-	    *level *= LEVEL_PLUS3DB / (2 + slev);
+	    adjust = DIV (LEVEL_PLUS3DB, LEVEL (2) + slev);
 	    break;
 
 	case CONVERT (A52_2F1R, A52_STEREO):
 	case CONVERT (A52_3F1R, A52_3F):
-	    *level /= 1 + slev * LEVEL_3DB;
+	    adjust = DIV (1, LEVEL (1) + MUL_C (slev, LEVEL_3DB));
 	    break;
 
 	case CONVERT (A52_3F1R, A52_MONO):
-	    *level *= LEVEL_3DB / (1 + clev + 0.5 * slev);
+	    adjust = DIV (LEVEL_3DB, LEVEL (1) + clev + MUL_C (slev, 0.5));
 	    break;
 
 	case CONVERT (A52_3F1R, A52_STEREO):
-	    *level /= 1 + clev + slev * LEVEL_3DB;
+	    adjust = DIV (1, LEVEL (1) + clev + MUL_C (slev, LEVEL_3DB));
 	    break;
 
 	case CONVERT (A52_2F2R, A52_MONO):
-	    *level *= LEVEL_3DB / (1 + slev);
+	    adjust = DIV (LEVEL_3DB, LEVEL (1) + slev);
 	    break;
 
 	case CONVERT (A52_2F2R, A52_STEREO):
 	case CONVERT (A52_3F2R, A52_3F):
-	    *level /= 1 + slev;
+	    adjust = DIV (1, LEVEL (1) + slev);
 	    break;
 
 	case CONVERT (A52_3F2R, A52_MONO):
-	    *level *= LEVEL_3DB / (1 + clev + slev);
+	    adjust = DIV (LEVEL_3DB, LEVEL (1) + clev + slev);
 	    break;
 
 	case CONVERT (A52_3F2R, A52_STEREO):
-	    *level /= 1 + clev + slev;
+	    adjust = DIV (1, LEVEL (1) + clev + slev);
 	    break;
 
 	case CONVERT (A52_MONO, A52_DOLBY):
-	    *level *= LEVEL_PLUS3DB;
+	    adjust = LEVEL (LEVEL_PLUS3DB);
 	    break;
 
 	case CONVERT (A52_3F, A52_DOLBY):
 	case CONVERT (A52_2F1R, A52_DOLBY):
-	    *level *= 1 / (1 + LEVEL_3DB);
+	    adjust = LEVEL (1 / (1 + LEVEL_3DB));
 	    break;
 
 	case CONVERT (A52_3F1R, A52_DOLBY):
 	case CONVERT (A52_2F2R, A52_DOLBY):
-	    *level *= 1 / (1 + 2 * LEVEL_3DB);
+	    adjust = LEVEL (1 / (1 + 2 * LEVEL_3DB));
 	    break;
 
 	case CONVERT (A52_3F2R, A52_DOLBY):
-	    *level *= 1 / (1 + 3 * LEVEL_3DB);
+	    adjust = LEVEL (1 / (1 + 3 * LEVEL_3DB));
 	    break;
+
+	default:
+	    return output;
 	}
 
+	*level = MUL_L (*level, adjust);
+    }
+
     return output;
 }
 
-int a52_downmix_coeff (sample_t * coeff, int acmod, int output, sample_t level,
-		       sample_t clev, sample_t slev)
+int a52_downmix_coeff (level_t * coeff, int acmod, int output, level_t level,
+		       level_t clev, level_t slev)
 {
+    level_t level_3db;
+
+    level_3db = MUL_C (level, LEVEL_3DB);
+
     switch (CONVERT (acmod, output & A52_CHANNEL_MASK)) {
 
     case CONVERT (A52_CHANNEL, A52_CHANNEL):
@@ -169,120 +181,138 @@
 	return 0;
 
     case CONVERT (A52_CHANNEL, A52_MONO):
-	coeff[0] = coeff[1] = level * LEVEL_6DB;
+	coeff[0] = coeff[1] = MUL_C (level, LEVEL_6DB);
 	return 3;
 
     case CONVERT (A52_STEREO, A52_MONO):
-	coeff[0] = coeff[1] = level * LEVEL_3DB;
+	coeff[0] = coeff[1] = level_3db;
 	return 3;
 
     case CONVERT (A52_3F, A52_MONO):
-	coeff[0] = coeff[2] = level * LEVEL_3DB;
-	coeff[1] = level * clev * LEVEL_PLUS3DB;
+	coeff[0] = coeff[2] = level_3db;
+	coeff[1] = MUL_C (MUL_L (level_3db, clev), LEVEL_PLUS6DB);
 	return 7;
 
     case CONVERT (A52_2F1R, A52_MONO):
-	coeff[0] = coeff[1] = level * LEVEL_3DB;
-	coeff[2] = level * slev * LEVEL_3DB;
+	coeff[0] = coeff[1] = level_3db;
+	coeff[2] = MUL_L (level_3db, slev);
 	return 7;
 
     case CONVERT (A52_2F2R, A52_MONO):
-	coeff[0] = coeff[1] = level * LEVEL_3DB;
-	coeff[2] = coeff[3] = level * slev * LEVEL_3DB;
+	coeff[0] = coeff[1] = level_3db;
+	coeff[2] = coeff[3] = MUL_L (level_3db, slev);
 	return 15;
 
     case CONVERT (A52_3F1R, A52_MONO):
-	coeff[0] = coeff[2] = level * LEVEL_3DB;
-	coeff[1] = level * clev * LEVEL_PLUS3DB;
-	coeff[3] = level * slev * LEVEL_3DB;
+	coeff[0] = coeff[2] = level_3db;
+	coeff[1] = MUL_C (MUL_L (level_3db, clev), LEVEL_PLUS6DB);
+	coeff[3] = MUL_L (level_3db, slev);
 	return 15;
 
     case CONVERT (A52_3F2R, A52_MONO):
-	coeff[0] = coeff[2] = level * LEVEL_3DB;
-	coeff[1] = level * clev * LEVEL_PLUS3DB;
-	coeff[3] = coeff[4] = level * slev * LEVEL_3DB;
+	coeff[0] = coeff[2] = level_3db;
+	coeff[1] = MUL_C (MUL_L (level_3db, clev), LEVEL_PLUS6DB);
+	coeff[3] = coeff[4] = MUL_L (level_3db, slev);
 	return 31;
 
     case CONVERT (A52_MONO, A52_DOLBY):
-	coeff[0] = level * LEVEL_3DB;
+	coeff[0] = level_3db;
 	return 0;
 
     case CONVERT (A52_3F, A52_DOLBY):
-	clev = LEVEL_3DB;
+	coeff[0] = coeff[2] = coeff[3] = coeff[4] = level;
+	coeff[1] = level_3db;
+	return 7;
+
     case CONVERT (A52_3F, A52_STEREO):
     case CONVERT (A52_3F1R, A52_2F1R):
     case CONVERT (A52_3F2R, A52_2F2R):
 	coeff[0] = coeff[2] = coeff[3] = coeff[4] = level;
-	coeff[1] = level * clev;
+	coeff[1] = MUL_L (level, clev);
 	return 7;
 
     case CONVERT (A52_2F1R, A52_DOLBY):
-	slev = 1;
+	coeff[0] = coeff[1] = level;
+	coeff[2] = level_3db;
+	return 7;
+
     case CONVERT (A52_2F1R, A52_STEREO):
 	coeff[0] = coeff[1] = level;
-	coeff[2] = level * slev * LEVEL_3DB;
+	coeff[2] = MUL_L (level_3db, slev);
 	return 7;
 
     case CONVERT (A52_3F1R, A52_DOLBY):
-	clev = LEVEL_3DB;
-	slev = 1;
+	coeff[0] = coeff[2] = level;
+	coeff[1] = coeff[3] = level_3db;
+	return 15;
+
     case CONVERT (A52_3F1R, A52_STEREO):
 	coeff[0] = coeff[2] = level;
-	coeff[1] = level * clev;
-	coeff[3] = level * slev * LEVEL_3DB;
+	coeff[1] = MUL_L (level, clev);
+	coeff[3] = MUL_L (level_3db, slev);
 	return 15;
 
     case CONVERT (A52_2F2R, A52_DOLBY):
-	slev = LEVEL_3DB;
+	coeff[0] = coeff[1] = level;
+	coeff[2] = coeff[3] = level_3db;
+	return 15;
+
     case CONVERT (A52_2F2R, A52_STEREO):
 	coeff[0] = coeff[1] = level;
-	coeff[2] = coeff[3] = level * slev;
+	coeff[2] = coeff[3] = MUL_L (level, slev);
 	return 15;
 
     case CONVERT (A52_3F2R, A52_DOLBY):
-	clev = LEVEL_3DB;
+	coeff[0] = coeff[2] = level;
+	coeff[1] = coeff[3] = coeff[4] = level_3db;
+	return 31;
+
     case CONVERT (A52_3F2R, A52_2F1R):
-	slev = LEVEL_3DB;
+	coeff[0] = coeff[2] = level;
+	coeff[1] = MUL_L (level, clev);
+	coeff[3] = coeff[4] = level_3db;
+	return 31;
+
     case CONVERT (A52_3F2R, A52_STEREO):
 	coeff[0] = coeff[2] = level;
-	coeff[1] = level * clev;
-	coeff[3] = coeff[4] = level * slev;
+	coeff[1] = MUL_L (level, clev);
+	coeff[3] = coeff[4] = MUL_L (level, slev);
 	return 31;
 
     case CONVERT (A52_3F1R, A52_3F):
 	coeff[0] = coeff[1] = coeff[2] = level;
-	coeff[3] = level * slev * LEVEL_3DB;
+	coeff[3] = MUL_L (level_3db, slev);
 	return 13;
 
     case CONVERT (A52_3F2R, A52_3F):
 	coeff[0] = coeff[1] = coeff[2] = level;
-	coeff[3] = coeff[4] = level * slev;
+	coeff[3] = coeff[4] = MUL_L (level, slev);
 	return 29;
 
     case CONVERT (A52_2F2R, A52_2F1R):
 	coeff[0] = coeff[1] = level;
-	coeff[2] = coeff[3] = level * LEVEL_3DB;
+	coeff[2] = coeff[3] = level_3db;
 	return 12;
 
     case CONVERT (A52_3F2R, A52_3F1R):
 	coeff[0] = coeff[1] = coeff[2] = level;
-	coeff[3] = coeff[4] = level * LEVEL_3DB;
+	coeff[3] = coeff[4] = level_3db;
 	return 24;
 
     case CONVERT (A52_2F1R, A52_2F2R):
 	coeff[0] = coeff[1] = level;
-	coeff[2] = level * LEVEL_3DB;
+	coeff[2] = level_3db;
 	return 0;
 
     case CONVERT (A52_3F1R, A52_2F2R):
 	coeff[0] = coeff[2] = level;
-	coeff[1] = level * clev;
-	coeff[3] = level * LEVEL_3DB;
+	coeff[1] = MUL_L (level, clev);
+	coeff[3] = level_3db;
 	return 7;
 
     case CONVERT (A52_3F1R, A52_3F2R):
 	coeff[0] = coeff[1] = coeff[2] = level;
-	coeff[3] = level * LEVEL_3DB;
+	coeff[3] = level_3db;
 	return 0;
 
     case CONVERT (A52_CHANNEL, A52_CHANNEL1):
@@ -304,7 +334,7 @@
     int i;
 
     for (i = 0; i < 256; i++)
-	dest[i] += src[i] + bias;
+	dest[i] += BIAS (src[i]);
 }
 
 static void mix3to1 (sample_t * samples, sample_t bias)
@@ -312,7 +342,7 @@
     int i;
 
     for (i = 0; i < 256; i++)
-	samples[i] += samples[i + 256] + samples[i + 512] + bias;
+	samples[i] += BIAS (samples[i + 256] + samples[i + 512]);
 }
 
 static void mix4to1 (sample_t * samples, sample_t bias)
@@ -320,8 +350,8 @@
     int i;
 
     for (i = 0; i < 256; i++)
-	samples[i] += (samples[i + 256] + samples[i + 512] +
-		       samples[i + 768] + bias);
+	samples[i] += BIAS (samples[i + 256] + samples[i + 512] +
+			    samples[i + 768]);
 }
 
 static void mix5to1 (sample_t * samples, sample_t bias)
@@ -329,8 +359,8 @@
     int i;
 
     for (i = 0; i < 256; i++)
-	samples[i] += (samples[i + 256] + samples[i + 512] +
-		       samples[i + 768] + samples[i + 1024] + bias);
+	samples[i] += BIAS (samples[i + 256] + samples[i + 512] +
+			    samples[i + 768] + samples[i + 1024]);
 }
 
 static void mix3to2 (sample_t * samples, sample_t bias)
@@ -339,7 +369,7 @@
     sample_t common;
 
     for (i = 0; i < 256; i++) {
-	common = samples[i + 256] + bias;
+	common = BIAS (samples[i + 256]);
 	samples[i] += common;
 	samples[i + 256] = samples[i + 512] + common;
     }
@@ -351,7 +381,7 @@
     sample_t common;
 
     for (i = 0; i < 256; i++) {
-	common = right[i + 256] + bias;
+	common = BIAS (right[i + 256]);
 	left[i] += common;
 	right[i] += common;
     }
@@ -364,8 +394,8 @@
 
     for (i = 0; i < 256; i++) {
 	surround = samples[i + 512];
-	samples[i] += bias - surround;
-	samples[i + 256] += bias + surround;
+	samples[i] += BIAS (-surround);
+	samples[i + 256] += BIAS (surround);
     }
 }
 
@@ -375,7 +405,7 @@
     sample_t common;
 
     for (i = 0; i < 256; i++) {
-	common = samples[i + 256] + samples[i + 768] + bias;
+	common = BIAS (samples[i + 256] + samples[i + 768]);
 	samples[i] += common;
 	samples[i + 256] = samples[i + 512] + common;
     }
@@ -387,7 +417,7 @@
     sample_t common, surround;
 
     for (i = 0; i < 256; i++) {
-	common = samples[i + 256] + bias;
+	common = BIAS (samples[i + 256]);
 	surround = samples[i + 768];
 	samples[i] += common - surround;
 	samples[i + 256] = samples[i + 512] + common + surround;
@@ -401,8 +431,8 @@
 
     for (i = 0; i < 256; i++) {
 	surround = samples[i + 512] + samples[i + 768];
-	samples[i] += bias - surround;
-	samples[i + 256] += bias + surround;
+	samples[i] += BIAS (-surround);
+	samples[i + 256] += BIAS (surround);
     }
 }
 
@@ -412,7 +442,7 @@
     sample_t common;
 
     for (i = 0; i < 256; i++) {
-	common = samples[i + 256] + bias;
+	common = BIAS (samples[i + 256]);
 	samples[i] += common + samples[i + 768];
 	samples[i + 256] = common + samples[i + 512] + samples[i + 1024];
     }
@@ -424,7 +454,7 @@
     sample_t common, surround;
 
     for (i = 0; i < 256; i++) {
-	common = samples[i + 256] + bias;
+	common = BIAS (samples[i + 256]);
 	surround = samples[i + 768] + samples[i + 1024];
 	samples[i] += common - surround;
 	samples[i + 256] = samples[i + 512] + common + surround;
@@ -436,7 +466,7 @@
     int i;
 
     for (i = 0; i < 256; i++)
-	dest[i] = src[i] + src[i + 256] + bias;
+	dest[i] = BIAS (src[i] + src[i + 256]);
 }
 
 static void zero (sample_t * samples)
@@ -448,8 +478,11 @@
 }
 
 void a52_downmix (sample_t * samples, int acmod, int output, sample_t bias,
-		  sample_t clev, sample_t slev)
+		  level_t clev, level_t slev)
 {
+    /* avoid compiler warning */
+    (void)clev;
+
     switch (CONVERT (acmod, output & A52_CHANNEL_MASK)) {
 
     case CONVERT (A52_CHANNEL, A52_CHANNEL2):
@@ -583,7 +616,7 @@
 	break;
 
     case CONVERT (A52_3F1R, A52_3F2R):
-	memcpy (samples + 1027, samples + 768, 256 * sizeof (sample_t));
+	memcpy (samples + 1024, samples + 768, 256 * sizeof (sample_t));
 	break;
     }
 }
diff -ruN a52dec.orig/liba52/imdct.c a52dec/liba52/imdct.c
--- a52dec.orig/liba52/imdct.c	2012-11-13 17:25:33.438758556 +0100
+++ a52dec/liba52/imdct.c	2012-11-13 17:27:31.150370945 +0100
@@ -1,6 +1,6 @@
 /*
  * imdct.c
- * Copyright (C) 2000-2002 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
  * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
  *
  * The ifft algorithms in this file have been largely inspired by Dan
@@ -24,12 +24,13 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "config.h"
+#include "config-a52.h"
 
 #include <math.h>
 #include <stdio.h>
 #ifdef LIBA52_DJBFFT
 #include <fftc4.h>
+#include <fftc8.h>
 #endif
 #ifndef M_PI
 #define M_PI 3.1415926535897932384626433832795029
@@ -57,25 +58,26 @@
 };
 
 /* Root values for IFFT */
-static sample_t roots16[3];
-static sample_t roots32[7];
-static sample_t roots64[15];
-static sample_t roots128[31];
+//static sample_t roots16[3];
+//static sample_t roots32[7];
+//static sample_t roots64[15];
+//static sample_t roots128[31];
 
 /* Twiddle factors for IMDCT */
-static complex_t pre1[128];
-static complex_t post1[64];
-static complex_t pre2[64];
-static complex_t post2[32];
+//static complex_t pre1[128];
+//static complex_t post1[64];
+//static complex_t pre2[64];
+//static complex_t post2[32];
 
-static sample_t a52_imdct_window[256];
+//static sample_t a52_imdct_window[256];
+#include "imdct_lookups.h"
 
 static void (* ifft128) (complex_t * buf);
 static void (* ifft64) (complex_t * buf);
 
 static inline void ifft2 (complex_t * buf)
 {
-    double r, i;
+    sample_t r, i;
 
     r = buf[0].real;
     i = buf[0].imag;
@@ -87,7 +89,7 @@
 
 static inline void ifft4 (complex_t * buf)
 {
-    double tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;
+    sample_t tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;
 
     tmp1 = buf[0].real + buf[1].real;
     tmp2 = buf[3].real + buf[2].real;
@@ -108,25 +110,37 @@
     buf[3].imag = tmp6 - tmp8;
 }
 
+/* basic radix-2 ifft butterfly */
+
+#define BUTTERFLY_0(t0,t1,W0,W1,d0,d1) do {	\
+    t0 = MUL (W1, d1) + MUL (W0, d0);		\
+    t1 = MUL (W0, d1) - MUL (W1, d0);		\
+} while (0)
+
+/* radix-2 ifft butterfly with bias */
+
+#define BUTTERFLY_B(t0,t1,W0,W1,d0,d1) do {	\
+    t0 = BIAS (MUL (d1, W1) + MUL (d0, W0));	\
+    t1 = BIAS (MUL (d1, W0) - MUL (d0, W1));	\
+} while (0)
+
 /* the basic split-radix ifft butterfly */
 
-#define BUTTERFLY(a0,a1,a2,a3,wr,wi) do {	\
-    tmp5 = a2.real * wr + a2.imag * wi;		\
-    tmp6 = a2.imag * wr - a2.real * wi;		\
-    tmp7 = a3.real * wr - a3.imag * wi;		\
-    tmp8 = a3.imag * wr + a3.real * wi;		\
-    tmp1 = tmp5 + tmp7;				\
-    tmp2 = tmp6 + tmp8;				\
-    tmp3 = tmp6 - tmp8;				\
-    tmp4 = tmp7 - tmp5;				\
-    a2.real = a0.real - tmp1;			\
-    a2.imag = a0.imag - tmp2;			\
-    a3.real = a1.real - tmp3;			\
-    a3.imag = a1.imag - tmp4;			\
-    a0.real += tmp1;				\
-    a0.imag += tmp2;				\
-    a1.real += tmp3;				\
-    a1.imag += tmp4;				\
+#define BUTTERFLY(a0,a1,a2,a3,wr,wi) do {		\
+    BUTTERFLY_0 (tmp5, tmp6, wr, wi, a2.real, a2.imag);	\
+    BUTTERFLY_0 (tmp8, tmp7, wr, wi, a3.imag, a3.real);	\
+    tmp1 = tmp5 + tmp7;					\
+    tmp2 = tmp6 + tmp8;					\
+    tmp3 = tmp6 - tmp8;					\
+    tmp4 = tmp7 - tmp5;					\
+    a2.real = a0.real - tmp1;				\
+    a2.imag = a0.imag - tmp2;				\
+    a3.real = a1.real - tmp3;				\
+    a3.imag = a1.imag - tmp4;				\
+    a0.real += tmp1;					\
+    a0.imag += tmp2;					\
+    a1.real += tmp3;					\
+    a1.imag += tmp4;					\
 } while (0)
 
 /* split-radix ifft butterfly, specialized for wr=1 wi=0 */
@@ -149,10 +163,10 @@
 /* split-radix ifft butterfly, specialized for wr=wi */
 
 #define BUTTERFLY_HALF(a0,a1,a2,a3,w) do {	\
-    tmp5 = (a2.real + a2.imag) * w;		\
-    tmp6 = (a2.imag - a2.real) * w;		\
-    tmp7 = (a3.real - a3.imag) * w;		\
-    tmp8 = (a3.imag + a3.real) * w;		\
+    tmp5 = MUL (a2.real + a2.imag, w);		\
+    tmp6 = MUL (a2.imag - a2.real, w);		\
+    tmp7 = MUL (a3.real - a3.imag, w);		\
+    tmp8 = MUL (a3.imag + a3.real, w);		\
     tmp1 = tmp5 + tmp7;				\
     tmp2 = tmp6 + tmp8;				\
     tmp3 = tmp6 - tmp8;				\
@@ -169,7 +183,7 @@
 
 static inline void ifft8 (complex_t * buf)
 {
-    double tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;
+    sample_t tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;
 
     ifft4 (buf);
     ifft2 (buf + 4);
@@ -183,7 +197,7 @@
     complex_t * buf1;
     complex_t * buf2;
     complex_t * buf3;
-    double tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;
+    sample_t tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;
     int i;
 
     buf++;
@@ -196,7 +210,8 @@
     i = n - 1;
 
     do {
-	BUTTERFLY (buf[0], buf1[0], buf2[0], buf3[0], weight[n], weight[2*i]);
+	BUTTERFLY (buf[0], buf1[0], buf2[0], buf3[0],
+		   weight[0], weight[2*i-n]);
 	buf++;
 	buf1++;
 	buf2++;
@@ -210,7 +225,7 @@
     ifft8 (buf);
     ifft4 (buf + 8);
     ifft4 (buf + 12);
-    ifft_pass (buf, roots16 - 4, 4);
+    ifft_pass (buf, roots16, 4);
 }
 
 static void ifft32 (complex_t * buf)
@@ -218,7 +233,7 @@
     ifft16 (buf);
     ifft8 (buf + 16);
     ifft8 (buf + 24);
-    ifft_pass (buf, roots32 - 8, 8);
+    ifft_pass (buf, roots32, 8);
 }
 
 static void ifft64_c (complex_t * buf)
@@ -226,7 +241,7 @@
     ifft32 (buf);
     ifft16 (buf + 32);
     ifft16 (buf + 48);
-    ifft_pass (buf, roots64 - 16, 16);
+    ifft_pass (buf, roots64, 16);
 }
 
 static void ifft128_c (complex_t * buf)
@@ -234,11 +249,11 @@
     ifft32 (buf);
     ifft16 (buf + 32);
     ifft16 (buf + 48);
-    ifft_pass (buf, roots64 - 16, 16);
+    ifft_pass (buf, roots64, 16);
 
     ifft32 (buf + 64);
     ifft32 (buf + 96);
-    ifft_pass (buf, roots128 - 32, 32);
+    ifft_pass (buf, roots128, 32);
 }
 
 void a52_imdct_512 (sample_t * data, sample_t * delay, sample_t bias)
@@ -252,9 +267,7 @@
 	k = fftorder[i];
 	t_r = pre1[i].real;
 	t_i = pre1[i].imag;
-
-	buf[i].real = t_i * data[255-k] + t_r * data[k];
-	buf[i].imag = t_r * data[255-k] - t_i * data[k];
+	BUTTERFLY_0 (buf[i].real, buf[i].imag, t_r, t_i, data[k], data[255-k]);
     }
 
     ifft128 (buf);
@@ -265,27 +278,22 @@
 	/* y[n] = z[n] * (xcos1[n] + j * xsin1[n]) ; */
 	t_r = post1[i].real;
 	t_i = post1[i].imag;
-
-	a_r = t_r * buf[i].real     + t_i * buf[i].imag;
-	a_i = t_i * buf[i].real     - t_r * buf[i].imag;
-	b_r = t_i * buf[127-i].real + t_r * buf[127-i].imag;
-	b_i = t_r * buf[127-i].real - t_i * buf[127-i].imag;
+	BUTTERFLY_0 (a_r, a_i, t_i, t_r, buf[i].imag, buf[i].real);
+	BUTTERFLY_0 (b_r, b_i, t_r, t_i, buf[127-i].imag, buf[127-i].real);
 
 	w_1 = window[2*i];
 	w_2 = window[255-2*i];
-	data[2*i]     = delay[2*i] * w_2 - a_r * w_1 + bias;
-	data[255-2*i] = delay[2*i] * w_1 + a_r * w_2 + bias;
+	BUTTERFLY_B (data[255-2*i], data[2*i], w_2, w_1, a_r, delay[2*i]);
 	delay[2*i] = a_i;
 
 	w_1 = window[2*i+1];
 	w_2 = window[254-2*i];
-	data[2*i+1]   = delay[2*i+1] * w_2 + b_r * w_1 + bias;
-	data[254-2*i] = delay[2*i+1] * w_1 - b_r * w_2 + bias;
+	BUTTERFLY_B (data[2*i+1], data[254-2*i], w_1, w_2, b_r, delay[2*i+1]);
 	delay[2*i+1] = b_i;
     }
 }
 
-void a52_imdct_256(sample_t * data, sample_t * delay, sample_t bias)
+void a52_imdct_256 (sample_t * data, sample_t * delay, sample_t bias)
 {
     int i, k;
     sample_t t_r, t_i, a_r, a_i, b_r, b_i, c_r, c_i, d_r, d_i, w_1, w_2;
@@ -297,12 +305,8 @@
 	k = fftorder[i];
 	t_r = pre2[i].real;
 	t_i = pre2[i].imag;
-
-	buf1[i].real = t_i * data[254-k] + t_r * data[k];
-	buf1[i].imag = t_r * data[254-k] - t_i * data[k];
-
-	buf2[i].real = t_i * data[255-k] + t_r * data[k+1];
-	buf2[i].imag = t_r * data[255-k] - t_i * data[k+1];
+	BUTTERFLY_0 (buf1[i].real, buf1[i].imag, t_r, t_i, data[k], data[254-k]);
+	BUTTERFLY_0 (buf2[i].real, buf2[i].imag, t_r, t_i, data[k+1], data[255-k]);
     }
 
     ifft64 (buf1);
@@ -314,43 +318,34 @@
 	/* y1[n] = z1[n] * (xcos2[n] + j * xs in2[n]) ; */ 
 	t_r = post2[i].real;
 	t_i = post2[i].imag;
-
-	a_r = t_r * buf1[i].real    + t_i * buf1[i].imag;
-	a_i = t_i * buf1[i].real    - t_r * buf1[i].imag;
-	b_r = t_i * buf1[63-i].real + t_r * buf1[63-i].imag;
-	b_i = t_r * buf1[63-i].real - t_i * buf1[63-i].imag;
-
-	c_r = t_r * buf2[i].real    + t_i * buf2[i].imag;
-	c_i = t_i * buf2[i].real    - t_r * buf2[i].imag;
-	d_r = t_i * buf2[63-i].real + t_r * buf2[63-i].imag;
-	d_i = t_r * buf2[63-i].real - t_i * buf2[63-i].imag;
+	BUTTERFLY_0 (a_r, a_i, t_i, t_r, buf1[i].imag, buf1[i].real);
+	BUTTERFLY_0 (b_r, b_i, t_r, t_i, buf1[63-i].imag, buf1[63-i].real);
+	BUTTERFLY_0 (c_r, c_i, t_i, t_r, buf2[i].imag, buf2[i].real);
+	BUTTERFLY_0 (d_r, d_i, t_r, t_i, buf2[63-i].imag, buf2[63-i].real);
 
 	w_1 = window[2*i];
 	w_2 = window[255-2*i];
-	data[2*i]     = delay[2*i] * w_2 - a_r * w_1 + bias;
-	data[255-2*i] = delay[2*i] * w_1 + a_r * w_2 + bias;
+	BUTTERFLY_B (data[255-2*i], data[2*i], w_2, w_1, a_r, delay[2*i]);
 	delay[2*i] = c_i;
 
 	w_1 = window[128+2*i];
 	w_2 = window[127-2*i];
-	data[128+2*i] = delay[127-2*i] * w_2 + a_i * w_1 + bias;
-	data[127-2*i] = delay[127-2*i] * w_1 - a_i * w_2 + bias;
+	BUTTERFLY_B (data[128+2*i], data[127-2*i], w_1, w_2, a_i, delay[127-2*i]);
 	delay[127-2*i] = c_r;
 
 	w_1 = window[2*i+1];
 	w_2 = window[254-2*i];
-	data[2*i+1]   = delay[2*i+1] * w_2 - b_i * w_1 + bias;
-	data[254-2*i] = delay[2*i+1] * w_1 + b_i * w_2 + bias;
+	BUTTERFLY_B (data[254-2*i], data[2*i+1], w_2, w_1, b_i, delay[2*i+1]);
 	delay[2*i+1] = d_r;
 
 	w_1 = window[129+2*i];
 	w_2 = window[126-2*i];
-	data[129+2*i] = delay[126-2*i] * w_2 + b_r * w_1 + bias;
-	data[126-2*i] = delay[126-2*i] * w_1 - b_r * w_2 + bias;
+	BUTTERFLY_B (data[129+2*i], data[126-2*i], w_1, w_2, b_r, delay[126-2*i]);
 	delay[126-2*i] = d_i;
     }
 }
 
+/*
 static double besselI0 (double x)
 {
     double bessel = 1;
@@ -361,66 +356,118 @@
     while (--i);
     return bessel;
 }
+*/
 
 void a52_imdct_init (uint32_t mm_accel)
 {
-    int i, k;
+  (void)mm_accel;
+/*    int i, k;
     double sum;
+    double local_imdct_window[256];*/
 
     /* compute imdct window - kaiser-bessel derived window, alpha = 5.0 */
-    sum = 0;
+    /*    sum = 0;
     for (i = 0; i < 256; i++) {
 	sum += besselI0 (i * (256 - i) * (5 * M_PI / 256) * (5 * M_PI / 256));
-	a52_imdct_window[i] = sum;
+	local_imdct_window[i] = sum;
     }
     sum++;
-    for (i = 0; i < 256; i++)
-	a52_imdct_window[i] = sqrt (a52_imdct_window[i] / sum);
+    */
+    /*    for (i = 0; i < 256; i++)
+	a52_imdct_window[i] = SAMPLE (sqrt (local_imdct_window[i] / sum));
+
+    printf("static sample_t a52_imdct_window[256]={");
+    for (i=0;i<256;i++) {
+      if ((i % 16)==0) { printf("\n"); }
+      printf("%d,",a52_imdct_window[i]);
+    }
+    printf("\n}\n");
+    */
+
+    /*    for (i = 0; i < 3; i++)
+	roots16[i] = SAMPLE (cos ((M_PI / 8) * (i + 1)));
 
-    for (i = 0; i < 3; i++)
-	roots16[i] = cos ((M_PI / 8) * (i + 1));
+    printf("static sample_t roots16[3]={%d,%d,%d};\n\n",roots16[0],roots16[1],roots16[2]);
 
     for (i = 0; i < 7; i++)
-	roots32[i] = cos ((M_PI / 16) * (i + 1));
+	roots32[i] = SAMPLE (cos ((M_PI / 16) * (i + 1)));
+
+    printf("static sample_t roots32[7]={");
+    for (i=0;i<7;i++) { printf("%d%s",roots32[i],(i < 6 ? "," : "")); }
+    printf("};\n");
 
     for (i = 0; i < 15; i++)
-	roots64[i] = cos ((M_PI / 32) * (i + 1));
+	roots64[i] = SAMPLE (cos ((M_PI / 32) * (i + 1)));
+
+    printf("static sample_t roots64[15]={");
+    for (i=0;i<15;i++) { printf("%d%s",roots64[i],(i < 14 ? "," : "")); }
+    printf("};\n");
 
     for (i = 0; i < 31; i++)
-	roots128[i] = cos ((M_PI / 64) * (i + 1));
+	roots128[i] = SAMPLE (cos ((M_PI / 64) * (i + 1)));
 
+    printf("static sample_t roots128[31]={");
+    for (i=0;i<31;i++) { printf("%d%s",roots128[i],(i < 30 ? "," : "")); }
+    printf("};\n");
+    */
+    /*
     for (i = 0; i < 64; i++) {
 	k = fftorder[i] / 2 + 64;
-	pre1[i].real = cos ((M_PI / 256) * (k - 0.25));
-	pre1[i].imag = sin ((M_PI / 256) * (k - 0.25));
+	pre1[i].real = SAMPLE (cos ((M_PI / 256) * (k - 0.25)));
+	pre1[i].imag = SAMPLE (sin ((M_PI / 256) * (k - 0.25)));
     }
 
     for (i = 64; i < 128; i++) {
 	k = fftorder[i] / 2 + 64;
-	pre1[i].real = -cos ((M_PI / 256) * (k - 0.25));
-	pre1[i].imag = -sin ((M_PI / 256) * (k - 0.25));
+	pre1[i].real = SAMPLE (-cos ((M_PI / 256) * (k - 0.25)));
+	pre1[i].imag = SAMPLE (-sin ((M_PI / 256) * (k - 0.25)));
     }
 
+    printf("static complex_t pre1[128]={");
+    for (i=0;i<128;i++) { printf("{%d,%d}%s",pre1[i].real,pre1[i].imag,(i < 127 ? "," : "")); }
+    printf("};\n");
+    */
+    /*
     for (i = 0; i < 64; i++) {
-	post1[i].real = cos ((M_PI / 256) * (i + 0.5));
-	post1[i].imag = sin ((M_PI / 256) * (i + 0.5));
+	post1[i].real = SAMPLE (cos ((M_PI / 256) * (i + 0.5)));
+	post1[i].imag = SAMPLE (sin ((M_PI / 256) * (i + 0.5)));
     }
 
+    printf("static complex_t post1[64]={");
+    for (i=0;i<64;i++) { printf("{%d,%d}%s",post1[i].real,post1[i].imag,(i < 63 ? "," : "")); }
+    printf("};\n");
+    */
+
+    /*
     for (i = 0; i < 64; i++) {
 	k = fftorder[i] / 4;
-	pre2[i].real = cos ((M_PI / 128) * (k - 0.25));
-	pre2[i].imag = sin ((M_PI / 128) * (k - 0.25));
+	pre2[i].real = SAMPLE (cos ((M_PI / 128) * (k - 0.25)));
+	pre2[i].imag = SAMPLE (sin ((M_PI / 128) * (k - 0.25)));
     }
 
+    printf("static complex_t pre2[64]={");
+    for (i=0;i<64;i++) { printf("{%d,%d}%s",pre2[i].real,pre2[i].imag,(i < 63 ? "," : "")); }
+    printf("};\n");
+
     for (i = 0; i < 32; i++) {
-	post2[i].real = cos ((M_PI / 128) * (i + 0.5));
-	post2[i].imag = sin ((M_PI / 128) * (i + 0.5));
+	post2[i].real = SAMPLE (cos ((M_PI / 128) * (i + 0.5)));
+	post2[i].imag = SAMPLE (sin ((M_PI / 128) * (i + 0.5)));
     }
 
+    printf("static complex_t post2[32]={");
+    for (i=0;i<32;i++) { printf("{%d,%d}%s",post2[i].real,post2[i].imag,(i < 31 ? "," : "")); }
+    printf("};\n");
+    */
+
 #ifdef LIBA52_DJBFFT
     if (mm_accel & MM_ACCEL_DJBFFT) {
+#ifndef LIBA52_DOUBLE
 	ifft128 = (void (*) (complex_t *)) fftc4_un128;
 	ifft64 = (void (*) (complex_t *)) fftc4_un64;
+#else
+	ifft128 = (void (*) (complex_t *)) fftc8_un128;
+	ifft64 = (void (*) (complex_t *)) fftc8_un64;
+#endif
     } else
 #endif
     {
diff -ruN a52dec.orig/liba52/imdct_lookups.h a52dec/liba52/imdct_lookups.h
--- a52dec.orig/liba52/imdct_lookups.h	1970-01-01 01:00:00.000000000 +0100
+++ a52dec/liba52/imdct_lookups.h	2012-11-13 17:27:31.150370945 +0100
@@ -0,0 +1,15 @@
+static sample_t a52_imdct_window[256]IDATA_ATTR={
+				       146020,261886,393529,545197,719447,918478,1144416,1399394,1685589,2005234,2360623,2754115,3188134,3665170,4187773,4758556, 5380193,6055411,6786995,7577779,8430645,9348521,10334375,11391212,12522071,13730020,15018150,16389576,17847424,19394833,21034947,22770912, 24605865,26542938,28585242,30735872,32997891,35374332,37868188,40482408,43219889,46083473,49075937,52199993,55458273,58853331,62387636,66063559, 69883377,73849259,77963266,82227341,86643307,91212859,95937560,100818835,105857968,111056092,116414194,121933098,127613474,133455822,139460477,145627601, 151957182,158449029,165102772,171917855,178893540,186028900,193322822,200774000,208380940,216141958,224055176,232118527,240329753,248686407,257185854,265825270, 274601649,283511802,292552357,301719768,311010314,320420105,329945084,339581031,349323572,359168178,369110174,379144743,389266934,399471665,409753732,420107815, 430528483,441010205,451547355,462134219,472765003,483433845,494134818,504861939,515609181,526370480,537139740,547910849,558677680,569434108,580174011,590891284, 601579849,612233658,622846709,633413050,643926788,654382103,664773249,675094567,685340494,695505569,705584441,715571877,725462772,735252152,744935184,754507184, 763963620,773300119,782512477,791596659,800548807,809365245,818042484,826577226,834966364,843206992,851296404,859232096,867011771,874633340,882094922,889394844, 896531647,903504079,910311101,916951881,923425798,929732436,935871584,941843233,947647575,953284997,958756080,964061593,969202490,974179906,978995149,983649698, 988145195,992483442,996666390,1000696136,1004574919,1008305104,1011889185,1015329772,1018629583,1021791439,1024818257,1027713038,1030478862,1033118881,1035636308,1038034411, 1040316504,1042485942,1044546109,1046500412,1048352275,1050105129,1051762405,1053327531,1054803917,1056194958,1057504020,1058734435,1059889501,1060972468,1061986539,1062934861, 1063820523,1064646551,1065415903,1066131467,1066796055,1067412403,1067983168,1068510924,1068998160,1069447282,1069860607,1070240366,1070588702,1070907668,1071199230,1071465266, 1071707567,1071927836,1072127692,1072308670,1072472221,1072619716,1072752449,1072871635,1072978415,1073073858,1073158963,1073234663,1073301826,1073361257,1073413702,1073459852, 1073500344,1073535763,1073566646,1073593486,1073616731,1073636791,1073654036,1073668804,1073681398,1073692090,1073701126,1073708726,1073715084,1073720373,1073724748,1073728344, 1073731279,1073733657,1073735568,1073737090,1073738291,1073739229,1073739951,1073740500,1073740912,1073741214,1073741431,1073741582,1073741685,1073741751,1073741792,1073741814
+};
+
+static sample_t roots16[3]IDATA_ATTR={992008094,759250124,410903206};
+static sample_t roots32[7]IDATA_ATTR={1053110175,992008094,892783698,759250124,596538995,410903206,209476638};
+static sample_t roots64[15]IDATA_ATTR={1068571463,1053110175,1027506861,992008094,946955747,892783698,830013654,759250124,681174602,596538995,506158392,410903206,311690798,209476638,105245103};
+static sample_t roots128[31]IDATA_ATTR={1072448454,1068571463,1062120190,1053110175,1041563127,1027506861,1010975241,992008094,970651112,946955747,920979082,892783698,862437519,830013654,795590212,759250124,721080937,681174602,639627257,596538995,552013618,506158392,459083785,410903206,361732725,311690798,260897981,209476638,157550647,105245103,52686014};
+
+static complex_t pre1[128]IDATA_ATTR={{761575898,756917205},{3294193,1073736770},{413944710,990742792},{-407857834,993264059},{599275209,890949340},{-206244755,1053747885},{-593797166,894609652},{212706548,1052462554},{683717842,827919933},{-101966276,1068889322},{314841678,1026545772},{-503250790,948504162},{-678624950,832099562},{108522938,1068243547},{509061229,945398418},{-308536985,1028458279},{723518379,793374223},{-49395540,1072605046},{364832651,1009860703},{-456103709,972054993},{554836544,919281193},{-257701283,1042358649},{-636978326,864395809},{160808444,1061631832},{-718636707,797798713},{55975991,1072281769},{462059540,969238095},{-358629394,1012080264},{642270168,860471112},{-154291366,1062598550},{-549185496,922668301},{264092224,1040757801},{742770847,775379244},{-23057618,1073494224},{389505993,1000603111},{-432110916,982955574},{577229727,905387953},{-232042906,1048369016},{-615573145,879767700},{186813761,1057365652},{663193747,844449855},{-128167423,1066065014},{289554159,1033963197},{-526376678,935868098},{-698841306,815194659},{82274244,1070585098},{485706670,957606670},{-333683689,1020576650},{-737999227,779922204},{29644020,1073332537},{438134083,980285687},{-383359075,1002974238},{620959710,875974053},{-180322371,1058492015},{-571663505,908912724},{238471209,1046925492},{703830091,810891303},{-75703709,1071069770},{339939548,1018509994},{-479821763,960568883},{-657999815,848503239},{134706262,1065258526},{532109148,932620694},{-283204430,1035720404},{-752230014,-766205918},{9882456,-1073696345},{-401755603,-995747929},{420016001,-988184225},{-588296766,-898236282},{219160333,-1051137599},{604730690,-887255485},{-199775197,-1054993542},{-673506508,-836247862},{115075515,-1067557553},{-302220675,-1030332066},{514852501,-942257080},{688784992,-823709134},{-95405775,-1069494853},{-497421404,-951574195},{321134518,-1024594615},{-713727978,-802193167},{62554335,-1071918121},{-352412636,-1014261720},{467997975,-966384705},{-543513771,-926020671},{270473222,-1039117770},{647537829,-856514018},{-147768480,-1063525261},{728372812,-788919863},{-42813229,-1072887940},{-450130706,-974835294},{371022172,-1007603122},{-631662502,-868287963},{167319467,-1060625145},{560466703,-915859475},{-251300639,-1043920252},{747514502,-770807091},{-16470347,-1073615495},{-426071479,-985588453},{395638246,-998194311},{-610163404,-883528225},{193298118,-1056199480},{582774217,-901829094},{-225605866,-1049773069},{-693826210,-819467323},{88841682,-1070060119},{-327415267,-1022604883},{491573291,-954608403},{668362709,-840364678},{-121623758,-1066831367},{-520624390,-939080267},{295892987,-1032167062},{-733199822,-784435800},{36229307,-1073130440},{-377197724,-1005307605},{444140755,-977578893},{-566075760,-912403275},{244890534,-1045442552},{626322896,-872147426},{-173824191,-1059578527},{708792377,-806557418},{-69130323,-1071514117},{-473918791,-963494932},{346182609,-1016404991},{-652781111,-852524677},{141240030,-1064411930},{537821584,-929338177},{-276844037,-1037438616}};
+
+static complex_t post1[64]IDATA_ATTR={{1073721611,6588355},{1073559912,19764075},{1073236539,32936819},{1072751541,46104602},{1072104991,59265442},{1071296985,72417357},{1070327646,85558366},{1069197119,98686490},{1067905576,111799753},{1066453209,124896178},{1064840239,137973795},{1063066908,151030634},{1061133483,164064728},{1059040255,177074114},{1056787539,190056834},{1054375675,203010932},{1051805026,215934457},{1049075979,228825463},{1046188946,241682009},{1043144359,254502159},{1039942680,267283981},{1036584388,280025551},{1033069991,292724951},{1029400017,305380267},{1025575020,317989594},{1021595574,330551034},{1017462280,343062693},{1013175760,355522688},{1008736660,367929143},{1004145647,380280189},{999403414,392573967},{994510674,404808624},{989468165,416982318},{984276645,429093217},{978936897,441139495},{973449725,453119340},{967815955,465030947},{962036435,476872521},{956112036,488642280},{950043650,500338452},{943832191,511959274},{937478594,523502998},{930983817,534967883},{924348836,546352205},{917574653,557654248},{910662286,568872310},{903612776,580004702},{896427186,591049747},{889106597,602005783},{881652112,612871159},{874064853,623644238},{866345963,634323399},{858496605,644907034},{850517961,655393547},{842411231,665781361},{834177638,676068911},{825818420,686254647},{817334837,696337035},{808728167,706314558},{799999705,716185713},{791150766,725949012},{782182683,735602987},{773096806,745146182},{763894503,754577161}};
+
+static complex_t pre2[64]IDATA_ATTR={{1073721611,-6588355},{763894503,754577161},{994510674,404808624},{416982318,989468165},{1054375675,203010932},{602005783,889106597},{215934457,1051805026},{896427186,591049747},{1069197119,98686490},{686254647,825818420},{950043650,500338452},{317989594,1025575020},{111799753,1067905576},{834177638,676068911},{1029400017,305380267},{511959274,943832191},{1072751541,46104602},{725949012,791150766},{973449725,453119340},{367929143,1008736660},{1043144359,254502159},{557654248,917574653},{164064728,1061133483},{866345963,634323399},{59265442,1072104991},{799999705,716185713},{1013175760,355522688},{465030947,967815955},{1063066908,151030634},{644907034,858496605},{267283981,1039942680},{924348836,546352205},{1073559912,19764075},{745146182,773096806},{984276645,429093217},{392573967,999403414},{1049075979,228825463},{580004702,903612776},{190056834,1056787539},{881652112,612871159},{1066453209,124896178},{665781361,842411231},{937478594,523502998},{292724951,1033069991},{85558366,1070327646},{817334837,696337035},{1021595574,330551034},{488642280,956112036},{32936819,1073236539},{782182683,735602987},{1004145647,380280189},{441139495,978936897},{1059040255,177074114},{623644238,874064853},{241682009,1046188946},{910662286,568872310},{1071296985,72417357},{706314558,808728167},{962036435,476872521},{343062693,1017462280},{137973795,1064840239},{850517961,655393547},{1036584388,280025551},{534967883,930983817}};
+static complex_t post2[32]IDATA_ATTR={{1073660973,13176463},{1073014239,39521454},{1071721163,65842639},{1069782521,92124162},{1067199482,118350193},{1063973603,144504935},{1060106825,170572632},{1055601479,196537583},{1050460278,222384146},{1044686318,248096754},{1038283079,273659918},{1031254417,299058239},{1023604566,324276418},{1015338134,349299266},{1006460100,374111709},{996975812,398698801},{986890983,423045731},{976211688,447137835},{964944359,470960600},{953095785,494499675},{940673100,517740882},{927683790,540670222},{914135677,563273882},{900036924,585538247},{885396022,607449906},{870221790,628995659},{854523369,650162530},{838310215,670937766},{821592095,691308855},{804379078,711263525},{786681534,730789756},{768510121,749875787}};
diff -ruN a52dec.orig/liba52/parse.c a52dec/liba52/parse.c
--- a52dec.orig/liba52/parse.c	2012-11-13 17:25:33.438758556 +0100
+++ a52dec/liba52/parse.c	2012-11-13 17:27:31.150370945 +0100
@@ -1,6 +1,6 @@
 /*
  * parse.c
- * Copyright (C) 2000-2002 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
  * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
  *
  * This file is part of a52dec, a free ATSC A-52 stream decoder.
@@ -21,9 +21,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#include "config.h"
+#include "config-a52.h"
 
-#include <stdlib.h>
 #include <string.h>
 #include <inttypes.h>
 
@@ -32,7 +31,7 @@
 #include "bitstream.h"
 #include "tables.h"
 
-#ifdef HAVE_MEMALIGN
+#if defined(HAVE_MEMALIGN) && !defined(__cplusplus)
 /* some systems have memalign() but no declaration for it */
 void * memalign (size_t align, size_t size);
 #else
@@ -41,13 +40,16 @@
 #endif
 
 typedef struct {
-    sample_t q1[2];
-    sample_t q2[2];
-    sample_t q4;
+    quantizer_t q1[2];
+    quantizer_t q2[2];
+    quantizer_t q4;
     int q1_ptr;
     int q2_ptr;
     int q4_ptr;
-} quantizer_t;
+} quantizer_set_t;
+
+static a52_state_t istate IBSS_ATTR;
+static sample_t isamples[256*12] IBSS_ATTR;
 
 static uint8_t halfrate[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3};
 
@@ -56,16 +58,25 @@
     a52_state_t * state;
     int i;
 
-    state = malloc (sizeof (a52_state_t));
+    #if defined(CPU_COLDFIRE)
+    coldfire_set_macsr(EMAC_FRACTIONAL | EMAC_ROUND | EMAC_SATURATE);
+    #endif
+    /* 
+      this needs to come back if we ever want two decoder instances
+      simultenously. NOTE, you also need to remove comments in a52_free.
+    state = (a52_state_t *) malloc (sizeof (a52_state_t));
     if (state == NULL)
 	return NULL;
 
-    state->samples = memalign (16, 256 * 12 * sizeof (sample_t));
+    state->samples = (sample_t *) memalign (16, 256 * 12 * sizeof (sample_t));
     if (state->samples == NULL) {
 	free (state);
 	return NULL;
     }
 
+    */
+    state = &istate;
+    state->samples = isamples;
     for (i = 0; i < 256 * 12; i++)
 	state->samples[i] = 0;
 
@@ -129,10 +140,12 @@
 }
 
 int a52_frame (a52_state_t * state, uint8_t * buf, int * flags,
-	       sample_t * level, sample_t bias)
+	       level_t * level, sample_t bias)
 {
-    static sample_t clev[4] = {LEVEL_3DB, LEVEL_45DB, LEVEL_6DB, LEVEL_45DB};
-    static sample_t slev[4] = {LEVEL_3DB, LEVEL_6DB, 0, LEVEL_6DB};
+    static level_t clev[4] = { LEVEL (LEVEL_3DB), LEVEL (LEVEL_45DB),
+			       LEVEL (LEVEL_6DB), LEVEL (LEVEL_45DB) };
+    static level_t slev[4] = { LEVEL (LEVEL_3DB), LEVEL (LEVEL_6DB), 
+			       0,                 LEVEL (LEVEL_6DB) };
     int chaninfo;
     int acmod;
 
@@ -146,6 +159,8 @@
     if ((acmod == 2) && (bitstream_get (state, 2) == 2))	/* dsurmod */
 	acmod = A52_DOLBY;
 
+    state->clev = state->slev = 0;
+
     if ((acmod & 1) && (acmod != 1))
 	state->clev = clev[bitstream_get (state, 2)];	/* cmixlev */
 
@@ -162,7 +177,7 @@
 	state->output |= A52_LFE;
     *flags = state->output;
     /* the 2* compensates for differences in imdct */
-    state->dynrng = state->level = 2 * *level;
+    state->dynrng = state->level = MUL_C (*level, 2);
     state->bias = bias;
     state->dynrnge = 1;
     state->dynrngcall = NULL;
@@ -201,7 +216,7 @@
 }
 
 void a52_dynrng (a52_state_t * state,
-		 sample_t (* call) (sample_t, void *), void * data)
+		 level_t (* call) (level_t, void *), void * data)
 {
     state->dynrnge = 0;
     if (call) {
@@ -311,20 +326,38 @@
 	
     state->lfsr_state = (uint16_t) nstate;
 
-    return nstate;
+    return (3 * nstate) >> 2;
 }
 
+#ifndef LIBA52_FIXED
+#define COEFF(c,t,l,s,e) (c) = (t) * (s)[e]
+#else
+#define COEFF(c,_t,_l,s,e) do {					\
+    quantizer_t t = (_t);					\
+    level_t l = (_l);						\
+    int shift = e - 5;						\
+    sample_t tmp = t * (l >> 16) + ((t * (l & 0xffff)) >> 16);	\
+    if (shift >= 0)						\
+	(c) = tmp >> shift;					\
+    else							\
+	(c) = tmp << -shift;					\
+} while (0)
+#endif
+
 static void coeff_get (a52_state_t * state, sample_t * coeff,
-		       expbap_t * expbap, quantizer_t * quantizer,
-		       sample_t level, int dither, int end)
+		       expbap_t * expbap, quantizer_set_t * quant,
+		       level_t level, int dither, int end)
 {
     int i;
     uint8_t * exp;
     int8_t * bap;
+
+#ifndef LIBA52_FIXED
     sample_t factor[25];
 
     for (i = 0; i <= 24; i++)
 	factor[i] = scale_factor[i] * level;
+#endif
 
     exp = expbap->exp;
     bap = expbap->bap;
@@ -336,7 +369,7 @@
 	switch (bapi) {
 	case 0:
 	    if (dither) {
-		coeff[i] = dither_gen (state) * LEVEL_3DB * factor[exp[i]];
+		COEFF (coeff[i], dither_gen (state), level, factor, exp[i]);
 		continue;
 	    } else {
 		coeff[i] = 0;
@@ -344,76 +377,80 @@
 	    }
 
 	case -1:
-	    if (quantizer->q1_ptr >= 0) {
-		coeff[i] = quantizer->q1[quantizer->q1_ptr--] * factor[exp[i]];
+	    if (quant->q1_ptr >= 0) {
+		COEFF (coeff[i], quant->q1[quant->q1_ptr--], level,
+		       factor, exp[i]);
 		continue;
 	    } else {
 		int code;
 
 		code = bitstream_get (state, 5);
 
-		quantizer->q1_ptr = 1;
-		quantizer->q1[0] = q_1_2[code];
-		quantizer->q1[1] = q_1_1[code];
-		coeff[i] = q_1_0[code] * factor[exp[i]];
+		quant->q1_ptr = 1;
+		quant->q1[0] = q_1_2[code];
+		quant->q1[1] = q_1_1[code];
+		COEFF (coeff[i], q_1_0[code], level, factor, exp[i]);
 		continue;
 	    }
 
 	case -2:
-	    if (quantizer->q2_ptr >= 0) {
-		coeff[i] = quantizer->q2[quantizer->q2_ptr--] * factor[exp[i]];
+	    if (quant->q2_ptr >= 0) {
+		COEFF (coeff[i], quant->q2[quant->q2_ptr--], level,
+		       factor, exp[i]);
 		continue;
 	    } else {
 		int code;
 
 		code = bitstream_get (state, 7);
 
-		quantizer->q2_ptr = 1;
-		quantizer->q2[0] = q_2_2[code];
-		quantizer->q2[1] = q_2_1[code];
-		coeff[i] = q_2_0[code] * factor[exp[i]];
+		quant->q2_ptr = 1;
+		quant->q2[0] = q_2_2[code];
+		quant->q2[1] = q_2_1[code];
+		COEFF (coeff[i], q_2_0[code], level, factor, exp[i]);
 		continue;
 	    }
 
 	case 3:
-	    coeff[i] = q_3[bitstream_get (state, 3)] * factor[exp[i]];
+	    COEFF (coeff[i], q_3[bitstream_get (state, 3)], level,
+		   factor, exp[i]);
 	    continue;
 
 	case -3:
-	    if (quantizer->q4_ptr == 0) {
-		quantizer->q4_ptr = -1;
-		coeff[i] = quantizer->q4 * factor[exp[i]];
+	    if (quant->q4_ptr == 0) {
+		quant->q4_ptr = -1;
+		COEFF (coeff[i], quant->q4, level, factor, exp[i]);
 		continue;
 	    } else {
 		int code;
 
 		code = bitstream_get (state, 7);
 
-		quantizer->q4_ptr = 0;
-		quantizer->q4 = q_4_1[code];
-		coeff[i] = q_4_0[code] * factor[exp[i]];
+		quant->q4_ptr = 0;
+		quant->q4 = q_4_1[code];
+		COEFF (coeff[i], q_4_0[code], level, factor, exp[i]);
 		continue;
 	    }
 
 	case 4:
-	    coeff[i] = q_5[bitstream_get (state, 4)] * factor[exp[i]];
+	    COEFF (coeff[i], q_5[bitstream_get (state, 4)], level,
+		   factor, exp[i]);
 	    continue;
 
 	default:
-	    coeff[i] = ((bitstream_get_2 (state, bapi) << (16 - bapi)) *
-			  factor[exp[i]]);
+	    COEFF (coeff[i], bitstream_get_2 (state, bapi) << (16 - bapi),
+		   level, factor, exp[i]);
 	}
     }
 }
 
 static void coeff_get_coupling (a52_state_t * state, int nfchans,
-				sample_t * coeff, sample_t (* samples)[256],
-				quantizer_t * quantizer, uint8_t dithflag[5])
+				level_t * coeff, sample_t (* samples)[256],
+				quantizer_set_t * quant, uint8_t dithflag[5])
 {
     int cplbndstrc, bnd, i, i_end, ch;
     uint8_t * exp;
     int8_t * bap;
-    sample_t cplco[5];
+    level_t cplco[5];
 
     exp = state->cpl_expbap.exp;
     bap = state->cpl_expbap.bap;
@@ -428,22 +465,26 @@
 	}
 	cplbndstrc >>= 1;
 	for (ch = 0; ch < nfchans; ch++)
-	    cplco[ch] = state->cplco[ch][bnd] * coeff[ch];
+	    cplco[ch] = MUL_L (state->cplco[ch][bnd], coeff[ch]);
 	bnd++;
 
 	while (i < i_end) {
-	    sample_t cplcoeff;
+	    quantizer_t cplcoeff;
 	    int bapi;
 
 	    bapi = bap[i];
 	    switch (bapi) {
 	    case 0:
-		cplcoeff = LEVEL_3DB * scale_factor[exp[i]];
 		for (ch = 0; ch < nfchans; ch++)
 		    if ((state->chincpl >> ch) & 1) {
 			if (dithflag[ch])
-			    samples[ch][i] = (cplcoeff * cplco[ch] *
-					      dither_gen (state));
+#ifndef LIBA52_FIXED
+			    samples[ch][i] = (scale_factor[exp[i]] *
+					      cplco[ch] * dither_gen (state));
+#else
+			    COEFF (samples[ch][i], dither_gen (state),
+				   cplco[ch], scale_factor, exp[i]);
+#endif
 			else
 			    samples[ch][i] = 0;
 		    }
@@ -451,33 +492,33 @@
 		continue;
 
 	    case -1:
-		if (quantizer->q1_ptr >= 0) {
-		    cplcoeff = quantizer->q1[quantizer->q1_ptr--];
+		if (quant->q1_ptr >= 0) {
+		    cplcoeff = quant->q1[quant->q1_ptr--];
 		    break;
 		} else {
 		    int code;
 
 		    code = bitstream_get (state, 5);
 
-		    quantizer->q1_ptr = 1;
-		    quantizer->q1[0] = q_1_2[code];
-		    quantizer->q1[1] = q_1_1[code];
+		    quant->q1_ptr = 1;
+		    quant->q1[0] = q_1_2[code];
+		    quant->q1[1] = q_1_1[code];
 		    cplcoeff = q_1_0[code];
 		    break;
 		}
 
 	    case -2:
-		if (quantizer->q2_ptr >= 0) {
-		    cplcoeff = quantizer->q2[quantizer->q2_ptr--];
+		if (quant->q2_ptr >= 0) {
+		    cplcoeff = quant->q2[quant->q2_ptr--];
 		    break;
 		} else {
 		    int code;
 
 		    code = bitstream_get (state, 7);
 
-		    quantizer->q2_ptr = 1;
-		    quantizer->q2[0] = q_2_2[code];
-		    quantizer->q2[1] = q_2_1[code];
+		    quant->q2_ptr = 1;
+		    quant->q2[0] = q_2_2[code];
+		    quant->q2[1] = q_2_1[code];
 		    cplcoeff = q_2_0[code];
 		    break;
 		}
@@ -487,17 +528,17 @@
 		break;
 
 	    case -3:
-		if (quantizer->q4_ptr == 0) {
-		    quantizer->q4_ptr = -1;
-		    cplcoeff = quantizer->q4;
+		if (quant->q4_ptr == 0) {
+		    quant->q4_ptr = -1;
+		    cplcoeff = quant->q4;
 		    break;
 		} else {
 		    int code;
 
 		    code = bitstream_get (state, 7);
 
-		    quantizer->q4_ptr = 0;
-		    quantizer->q4 = q_4_1[code];
+		    quant->q4_ptr = 0;
+		    quant->q4 = q_4_1[code];
 		    cplcoeff = q_4_0[code];
 		    break;
 		}
@@ -509,11 +550,17 @@
 	    default:
 		cplcoeff = bitstream_get_2 (state, bapi) << (16 - bapi);
 	    }
-
+#ifndef LIBA52_FIXED
 	    cplcoeff *= scale_factor[exp[i]];
+#endif
 	    for (ch = 0; ch < nfchans; ch++)
-		if ((state->chincpl >> ch) & 1)
+	       if ((state->chincpl >> ch) & 1)
+#ifndef LIBA52_FIXED
 		    samples[ch][i] = cplcoeff * cplco[ch];
+#else
+		    COEFF (samples[ch][i], cplcoeff, cplco[ch],
+			   scale_factor, exp[i]);
+#endif
 	    i++;
 	}
     }
@@ -526,9 +573,9 @@
     int i, nfchans, chaninfo;
     uint8_t cplexpstr, chexpstr[5], lfeexpstr, do_bit_alloc, done_cpl;
     uint8_t blksw[5], dithflag[5];
-    sample_t coeff[5];
+    level_t coeff[5];
     int chanbias;
-    quantizer_t quantizer;
+    quantizer_set_t quant;
     sample_t * samples;
 
     nfchans = nfchans_tbl[state->acmod];
@@ -546,13 +593,17 @@
 
 	    dynrng = bitstream_get_2 (state, 8);
 	    if (state->dynrnge) {
-		sample_t range;
+		level_t range;
 
+#if !defined(LIBA52_FIXED)
 		range = ((((dynrng & 0x1f) | 0x20) << 13) *
 			 scale_factor[3 - (dynrng >> 5)]);
+#else
+		range = ((dynrng & 0x1f) | 0x20) << (21 + (dynrng >> 5));
+#endif
 		if (state->dynrngcall)
 		    range = state->dynrngcall (range, state->dynrngdata);
-		state->dynrng = state->level * range;
+		state->dynrng = MUL_L (state->level, range);
 	    }
 	}
     } while (chaninfo--);
@@ -611,8 +662,13 @@
 			    cplcomant <<= 14;
 			else
 			    cplcomant = (cplcomant | 0x10) << 13;
+#ifndef LIBA52_FIXED
 			state->cplco[i][j] =
 			    cplcomant * scale_factor[cplcoexp + mstrcplco];
+#else
+			state->cplco[i][j] = (cplcomant << 11) >> (cplcoexp + mstrcplco);
+#endif
+
 		    }
 		}
 	if ((state->acmod == 2) && state->phsflginu && cplcoe)
@@ -691,11 +747,11 @@
     }
 
     if (bitstream_get (state, 1)) {	/* baie */
-	do_bit_alloc = -1;
+	do_bit_alloc = 127;
 	state->bai = bitstream_get (state, 11);
     }
     if (bitstream_get (state, 1)) {	/* snroffste */
-	do_bit_alloc = -1;
+	do_bit_alloc = 127;
 	state->csnroffst = bitstream_get (state, 6);
 	if (state->chincpl)	/* cplinu */
 	    state->cplba.bai = bitstream_get (state, 7);
@@ -711,7 +767,7 @@
     }
 
     if (bitstream_get (state, 1)) {	/* deltbaie */
-	do_bit_alloc = -1;
+	do_bit_alloc = 127;
 	if (state->chincpl)	/* cplinu */
 	    state->cplba.deltbae = bitstream_get (state, 2);
 	for (i = 0; i < nfchans; i++)
@@ -765,20 +821,20 @@
     chanbias = a52_downmix_coeff (coeff, state->acmod, state->output,
 				  state->dynrng, state->clev, state->slev);
 
-    quantizer.q1_ptr = quantizer.q2_ptr = quantizer.q4_ptr = -1;
+    quant.q1_ptr = quant.q2_ptr = quant.q4_ptr = -1;
     done_cpl = 0;
 
     for (i = 0; i < nfchans; i++) {
 	int j;
 
-	coeff_get (state, samples + 256 * i, state->fbw_expbap +i, &quantizer,
+	coeff_get (state, samples + 256 * i, state->fbw_expbap +i, &quant,
 		   coeff[i], dithflag[i], state->endmant[i]);
 
 	if ((state->chincpl >> i) & 1) {
 	    if (!done_cpl) {
 		done_cpl = 1;
 		coeff_get_coupling (state, nfchans, coeff,
-				    (sample_t (*)[256])samples, &quantizer,
+				    (sample_t (*)[256])samples, &quant,
 				    dithflag);
 	    }
 	    j = state->cplendmant;
@@ -821,14 +877,14 @@
 
     if (state->lfeon) {
 	if (state->output & A52_LFE) {
-	    coeff_get (state, samples - 256, &state->lfe_expbap, &quantizer,
+	    coeff_get (state, samples - 256, &state->lfe_expbap, &quant,
 		       state->dynrng, 0, 7);
 	    for (i = 7; i < 256; i++)
 		(samples-256)[i] = 0;
 	    a52_imdct_512 (samples - 256, samples + 1536 - 256, state->bias);
 	} else {
 	    /* just skip the LFE coefficients */
-	    coeff_get (state, samples + 1280, &state->lfe_expbap, &quantizer,
+	    coeff_get (state, samples + 1280, &state->lfe_expbap, &quant,
 		       0, 0, 7);
 	}
     }
@@ -896,6 +952,9 @@
 
 void a52_free (a52_state_t * state)
 {
+    (void)state;
+    /*
     free (state->samples);
     free (state);
+    */
 }
diff -ruN a52dec.orig/liba52/tables.h a52dec/liba52/tables.h
--- a52dec.orig/liba52/tables.h	2012-11-13 17:25:33.438758556 +0100
+++ a52dec/liba52/tables.h	2012-11-13 17:27:31.150370945 +0100
@@ -1,6 +1,6 @@
 /*
  * tables.h
- * Copyright (C) 2000-2002 Michel Lespinasse <walken@zoy.org>
+ * Copyright (C) 2000-2003 Michel Lespinasse <walken@zoy.org>
  * Copyright (C) 1999-2000 Aaron Holtzman <aholtzma@ess.engr.uvic.ca>
  *
  * This file is part of a52dec, a free ATSC A-52 stream decoder.
@@ -46,42 +46,44 @@
     25,25,25
 };
 
-#define Q0 ((-2 << 15) / 3.0)
-#define Q1 (0)
-#define Q2 ((2 << 15) / 3.0)
-
-static const sample_t q_1_0[32] = {
-    Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,
-    Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,
-    Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,
-    0,0,0,0,0
-};
-
-static const sample_t q_1_1[32] = {
-    Q0,Q0,Q0,Q1,Q1,Q1,Q2,Q2,Q2,
-    Q0,Q0,Q0,Q1,Q1,Q1,Q2,Q2,Q2,
-    Q0,Q0,Q0,Q1,Q1,Q1,Q2,Q2,Q2,
-    0,0,0,0,0
-};
-
-static const sample_t q_1_2[32] = {
-    Q0,Q1,Q2,Q0,Q1,Q2,Q0,Q1,Q2,
-    Q0,Q1,Q2,Q0,Q1,Q2,Q0,Q1,Q2,
-    Q0,Q1,Q2,Q0,Q1,Q2,Q0,Q1,Q2,
-    0,0,0,0,0
+#define Q(x) ROUND (32768.0 * x)
+
+#define Q0 Q (-2/3)
+#define Q1 Q (0)
+#define Q2 Q (2/3)
+
+static const quantizer_t q_1_0[32] = {
+    Q0, Q0, Q0, Q0, Q0, Q0, Q0, Q0, Q0,
+    Q1, Q1, Q1, Q1, Q1, Q1, Q1, Q1, Q1,
+    Q2, Q2, Q2, Q2, Q2, Q2, Q2, Q2, Q2,
+    0,  0,  0,  0,  0
+};
+
+static const quantizer_t q_1_1[32] = {
+    Q0, Q0, Q0, Q1, Q1, Q1, Q2, Q2, Q2,
+    Q0, Q0, Q0, Q1, Q1, Q1, Q2, Q2, Q2,
+    Q0, Q0, Q0, Q1, Q1, Q1, Q2, Q2, Q2,
+    0,  0,  0,  0,  0
+};
+
+static const quantizer_t q_1_2[32] = {
+    Q0, Q1, Q2, Q0, Q1, Q2, Q0, Q1, Q2,
+    Q0, Q1, Q2, Q0, Q1, Q2, Q0, Q1, Q2,
+    Q0, Q1, Q2, Q0, Q1, Q2, Q0, Q1, Q2,
+    0,  0,  0,  0,  0
 };
 
 #undef Q0
 #undef Q1
 #undef Q2
 
-#define Q0 ((-4 << 15) / 5.0)
-#define Q1 ((-2 << 15) / 5.0)
-#define Q2 (0)
-#define Q3 ((2 << 15) / 5.0)
-#define Q4 ((4 << 15) / 5.0)
+#define Q0 Q (-4/5)
+#define Q1 Q (-2/5)
+#define Q2 Q (0)
+#define Q3 Q (2/5)
+#define Q4 Q (4/5)
 
-static const sample_t q_2_0[128] = {
+static const quantizer_t q_2_0[128] = {
     Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,Q0,
     Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,Q1,
     Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,Q2,
@@ -90,7 +92,7 @@
     0,0,0
 };
 
-static const sample_t q_2_1[128] = {
+static const quantizer_t q_2_1[128] = {
     Q0,Q0,Q0,Q0,Q0,Q1,Q1,Q1,Q1,Q1,Q2,Q2,Q2,Q2,Q2,Q3,Q3,Q3,Q3,Q3,Q4,Q4,Q4,Q4,Q4,
     Q0,Q0,Q0,Q0,Q0,Q1,Q1,Q1,Q1,Q1,Q2,Q2,Q2,Q2,Q2,Q3,Q3,Q3,Q3,Q3,Q4,Q4,Q4,Q4,Q4,
     Q0,Q0,Q0,Q0,Q0,Q1,Q1,Q1,Q1,Q1,Q2,Q2,Q2,Q2,Q2,Q3,Q3,Q3,Q3,Q3,Q4,Q4,Q4,Q4,Q4,
@@ -99,7 +101,7 @@
     0,0,0
 };
 
-static const sample_t q_2_2[128] = {
+static const quantizer_t q_2_2[128] = {
     Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,
     Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,
     Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,Q0,Q1,Q2,Q3,Q4,
@@ -114,24 +116,23 @@
 #undef Q3
 #undef Q4
 
-static const sample_t q_3[8] = {
-    (-6 << 15)/7.0, (-4 << 15)/7.0, (-2 << 15)/7.0, 0,
-    ( 2 << 15)/7.0, ( 4 << 15)/7.0, ( 6 << 15)/7.0, 0
-};
-
-#define Q0 ((-10 << 15) / 11.0)
-#define Q1 ((-8 << 15) / 11.0)
-#define Q2 ((-6 << 15) / 11.0)
-#define Q3 ((-4 << 15) / 11.0)
-#define Q4 ((-2 << 15) / 11.0)
-#define Q5 (0)
-#define Q6 ((2 << 15) / 11.0)
-#define Q7 ((4 << 15) / 11.0)
-#define Q8 ((6 << 15) / 11.0)
-#define Q9 ((8 << 15) / 11.0)
-#define QA ((10 << 15) / 11.0)
+static const quantizer_t q_3[8] = {
+    Q (-6/7), Q (-4/7), Q (-2/7), Q (0), Q (2/7), Q (4/7), Q (6/7), 0
+};
+
+#define Q0 Q (-10/11)
+#define Q1 Q (-8/11)
+#define Q2 Q (-6/11)
+#define Q3 Q (-4/11)
+#define Q4 Q (-2/11)
+#define Q5 Q (0)
+#define Q6 Q (2/11)
+#define Q7 Q (4/11)
+#define Q8 Q (6/11)
+#define Q9 Q (8/11)
+#define QA Q (10/11)
 
-static const sample_t q_4_0[128] = {
+static const quantizer_t q_4_0[128] = {
     Q0, Q0, Q0, Q0, Q0, Q0, Q0, Q0, Q0, Q0, Q0,
     Q1, Q1, Q1, Q1, Q1, Q1, Q1, Q1, Q1, Q1, Q1,
     Q2, Q2, Q2, Q2, Q2, Q2, Q2, Q2, Q2, Q2, Q2,
@@ -146,7 +147,7 @@
     0,  0,  0,  0,  0,  0,  0
 };
 
-static const sample_t q_4_1[128] = {
+static const quantizer_t q_4_1[128] = {
     Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
     Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
     Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, QA,
@@ -173,15 +174,13 @@
 #undef Q9
 #undef QA
 
-static const sample_t q_5[16] = {
-    (-14 << 15)/15.0,(-12 << 15)/15.0,(-10 << 15)/15.0,
-    ( -8 << 15)/15.0,( -6 << 15)/15.0,( -4 << 15)/15.0,
-    ( -2 << 15)/15.0,   0            ,(  2 << 15)/15.0,
-    (  4 << 15)/15.0,(  6 << 15)/15.0,(  8 << 15)/15.0,
-    ( 10 << 15)/15.0,( 12 << 15)/15.0,( 14 << 15)/15.0,
-    0
+static const quantizer_t q_5[16] = {
+    Q (-14/15), Q (-12/15), Q (-10/15), Q (-8/15), Q (-6/15),
+    Q (-4/15), Q (-2/15), Q (0), Q (2/15), Q (4/15),
+    Q (6/15), Q (8/15), Q (10/15), Q (12/15), Q (14/15), 0
 };
 
+#ifndef LIBA52_FIXED
 static const sample_t scale_factor[25] = {
     0.000030517578125,
     0.0000152587890625,
@@ -209,6 +208,7 @@
     0.00000000000363797880709171295166015625,
     0.000000000001818989403545856475830078125
 };
+#endif
 
 static const uint16_t dither_lut[256] = {
     0x0000, 0xa011, 0xe033, 0x4022, 0x6077, 0xc066, 0x8044, 0x2055,
